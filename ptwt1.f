
CMOCWT  PTWT.F
C
C SUBROUTINES USED FOR WEIGHTED PARTICLES OPTION
C
C  GWT1IPDL1DF  READ INITIAL PARTICLE DENSITY FILE INFO (LIST-BASED) IPDL
C
C***************************************************************
C
      SUBROUTINE GWT1IPDL1DF(INIPDL,NPTLAY,NPTROW,NPTCOL,NPTLIST,
     *                    NPMAX,IOUTS,NPTLAYA,NPTROWA,NPTCOLA,
     *                    NCOL,NROW,NLAY,NSCOL,NSROW,NSLAY,NLIMBO,IDIM)
C
C     READ IPDL FILE
C     ******************************************************************
C
      DIMENSION NPTLAYA(NSCOL,NSROW,NSLAY),NPTROWA(NSCOL,NSROW,NSLAY),
     *          NPTCOLA(NSCOL,NSROW,NSLAY)
      CHARACTER*200 LINE
C
      COMMON /SUBGRD/
     *  ISCOL1,ISCOL2,ISROW1,ISROW2,ISLAY1,ISLAY2,ISUBGD
C
C     READ COMMENTS 
      CALL URDCOM(INIPDL,IOUTS,LINE)
C     READ IPDL PARAMETERS
      LLOC=1
      CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,NPTLAY,R,IOUTS,INIPDL)
      CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,NPTROW,R,IOUTS,INIPDL)
      CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,NPTCOL,R,IOUTS,INIPDL)
      CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,NPTLIST,R,IOUTS,INIPDL)
      CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,NPMAX,R,IOUTS,INIPDL)
c      READ(INIPDL,*) NPTLAY,NPTROW,NPTCOL,NPTLIST,NPMAX
      WRITE(IOUTS,*) 'IPDL FILE PARAMETERS:'
      WRITE(IOUTS,*) 'NPTLAY  = ',NPTLAY
      WRITE(IOUTS,*) 'NPTROW  = ',NPTROW
      WRITE(IOUTS,*) 'NPTCOL  = ',NPTCOL
      WRITE(IOUTS,*) 'NPTLIST = ',NPTLIST
      WRITE(IOUTS,*) 'NPMAX   = ',NPMAX
      WRITE(IOUTS,'(/)')
C  CHECK FOR DIMENSION RESTRAINTS
      IF (NLAY.EQ.1.AND.NPTLAY.NE.1) THEN
         NPTLAY=1
	   WRITE(IOUTS,*) 'NLAY=1, RE-SETTING NPTLAY=1'
	END IF
      IF (NROW.EQ.1.AND.NPTROW.NE.1) THEN
         NPTROW=1
	   WRITE(IOUTS,*) 'NROW=1, RE-SETTING NPTROW=1'
	END IF
      IF (NCOL.EQ.1.AND.NPTCOL.NE.1) THEN
         NPTCOL=1
	   WRITE(IOUTS,*) 'NCOL=1, RE-SETTING NPTCOL=1'
	END IF
C  TRACK MAX PTS IN ANY CELL
	IF (NPMAX.EQ.0) MAXIPTS=NPTLAY*NPTROW*NPTCOL
C  FILL NPT ARRAYS
cgzh   f90 allows uniform array fill without do loop
      NPTLAYA=NPTLAY
      NPTROWA=NPTROW
      NPTCOLA=NPTCOL
C  TRACK INITIAL NUMBER OF PARTICLES IN THE GRID TO CALCULATE NLIMBO
cgzh this is npts*cells defined by background
      NPGRID=(NPTLAY*NPTROW*NPTCOL)*((NSROW*NSCOL*NSLAY)-NPTLIST)
C  READ LIST AND UPDATE ARRAYS
	DO 10 I=1,NPTLIST
        READ(INIPDL,*) IL,IR,IC,NPTLAY
        BACKSPACE INIPDL
        IF(NPTLAY.GT.0) THEN
          READ(INIPDL,*) IL,IR,IC,NPTLAY,NPTROW,NPTCOL
        ELSE
          READ(INIPDL,*) IL,IR,IC,NPTLAY
	  END IF
C CHECK FOR BAD INPUT
        IF(NPTLAY.EQ.0) THEN
	    NPTLAY=1
	    WRITE(IOUTS,*) 'NPTLAY READ AS 0, RE-SETTING NPTLAY=1'
        END IF
        IF(NPTROW.EQ.0) THEN
	    NPTROW=1
	    WRITE(IOUTS,*) 'NPTLAY READ AS 0, RE-SETTING NPTROW=1'
        END IF
        IF(NPTCOL.EQ.0) THEN
	    NPTCOL=1
	    WRITE(IOUTS,*) 'NPTLAY READ AS 0, RE-SETTING NPTCOL=1'
        END IF
C  CHECK FOR DIMENSION RESTRAINTS
        IF ((NLAY.EQ.1.AND.NPTLAY.NE.1).AND.NPTLAY.GT.0) THEN
          NPTLAY=1
	    WRITE(IOUTS,*) 'NLAY=1, RE-SETTING NPTLAY=1'
	  END IF
        IF ((NROW.EQ.1.AND.NPTROW.NE.1).AND.NPTLAY.GT.0) THEN
          NPTROW=1
	    WRITE(IOUTS,*) 'NROW=1, RE-SETTING NPTROW=1'
	  END IF
        IF ((NCOL.EQ.1.AND.NPTCOL.NE.1).AND.NPTLAY.GT.0) THEN
          NPTCOL=1
	    WRITE(IOUTS,*) 'NCOL=1, RE-SETTING NPTCOL=1'
	  END IF
cgzh square
cgzh circle
        IF(NPTLAY.LT.0) THEN
	    IF(IDIM.EQ.1) THEN
            WRITE(IOUTS,*) 'NPTLAY<0 NOT COMPATIBLE WITH ONE-D PROBLEM'
		  STOP 'ERROR IN PTWT; SEE GWT OUTPUT FILE'
          END IF
		IF(ABS(NPTLAY).LT.2) THEN
            NPTLAY=-4
	    WRITE(IOUTS,*) '***WARNING*** NPTLAY OUT OF RANGE,' 
     * ,' RE-SETTING NPTLAY=-4'		      
          END IF
        END IF
	  ICS=IC-ISCOL1+1
        IRS=IR-ISROW1+1
        ILS=IL-ISLAY1+1
cgzh check for IPDL cell outside subgrid
        IERRSG=0
        IF(ICS.LT.1.OR.ICS.GT.NSCOL) IERRSG=1
        IF(IRS.LT.1.OR.IRS.GT.NSROW) IERRSG=1
        IF(ILS.LT.1.OR.ILS.GT.NSLAY) IERRSG=1
        IF(IERRSG.EQ.1) THEN
          WRITE(IOUTS,*) ' ***ERROR*** IPDL CELL OUTSIDE SUBGRID'
          WRITE(IOUTS,*) ' CELL J,I,K', IC,IR,IL
          STOP 'ERROR IN PTWT'
        ELSE
cgzh debug this output is too lengthy for big problems
        continue
c          WRITE(IOUTS,*) 'IPDL REDEFINED AT J,I,K: ',IC,IR,IL,' AS:'
c
        END IF
	  NPTLAYA(ICS,IRS,ILS)=NPTLAY
        IF(NPTLAY.GT.0) THEN
          NPTROWA(ICS,IRS,ILS)=NPTROW
          NPTCOLA(ICS,IRS,ILS)=NPTCOL
        END IF
cgzh circle
C     CHECK FOR FLAG TO CREATE CIRCLE OF PARTICLES
cgzh square
C     CHECK FOR FLAG TO CREATE SQUARE OF PARTICLES
        IF(NPTLAY.LT.0) THEN
         WRITE(IOUTS,*) 'CIRCLE OF ',-NPTLAY,' PARTICLES'
cgzh square
c          IF(IDIM.EQ.2) THEN 
c            WRITE(IOUTS,*) 'SQUARE WITH ',-NPTLAY,
c     *      ' PARTICLES ON EACH SIDE'
c          ELSE 
c            WRITE(IOUTS,*) 'CUBE WITH ',-NPTLAY,
c     *      ' PARTICLES ON EACH SIDE'
c          END IF
C
C     IF NPTLAY IS POSITIVE, USE REGULAR DEFINITION FOR IPDL  
        ELSE
cgzh debug this output is too lengthy for big problems
        continue
c          WRITE(IOUTS,*) 'NPTLAY,NPTROW,NPTCOL= ',NPTLAY,NPTROW,NPTCOL
c
        END IF
C  TRACK MAX PTS IN ANY CELL
C  TRACK INITIAL NUMBER OF PARTICLES IN THE GRID TO CALCULATE NLIMBO
	  IF (NPMAX.EQ.0) THEN
	    IF(NPTLAY.GT.0) THEN
		  MAXIPTS=MAX(MAXIPTS,NPTLAY*NPTROW*NPTCOL)
            NPGRID=NPGRID+(NPTLAY*NPTROW*NPTCOL)
	    ELSE
cgzh square
c		  MAXIPTS=MAX(MAXIPTS,ABS((4*NPTLAY)-4))
c            NPGRID=NPGRID+(ABS((4*NPTLAY)-4))
cgzh circle
		  MAXIPTS=MAX(MAXIPTS,ABS(NPTLAY))
            NPGRID=NPGRID+(ABS(NPTLAY))
          END IF
        END IF
  10  CONTINUE
C  CALCULATE DEFAULT NPMAX VALUE
      WRITE(IOUTS,'(/)')
	IF (NPMAX.EQ.0) THEN
C  Changed definition for weighted, base it on NPGRID 
cgzh        NPMAX=2*MAXIPTS*NSCOL*NSROW*NSLAY
        NPMAX=2*NPGRID
C
        WRITE(IOUTS,*) 'NPMAX=0, USING DEFAULT CALCULATION'
        WRITE(IOUTS,*) 'MAXIPTS= ',MAXIPTS,'; NPMAX= ',NPMAX
        WRITE(IOUTS,'(/)')
      END IF
C  CALCULATE NLIMBO
      NLIMBO=500
      NTEMP=NPGRID/25
      IF(NTEMP.GT.NLIMBO) NLIMBO=NTEMP
C
      RETURN
      END
C
C  GWT1IPDA1DF  READ INITIAL PARTICLE DENSITY FILE INFO (ARRAY-BASED) IPDL
C
C***************************************************************
C
      SUBROUTINE GWT1IPDA1DF(INIPDA,NPMAX,IOUTS,NPTLAYA,NPTROWA,NPTCOLA,
     *         NCOL,NROW,NLAY,NSCOL,NSROW,NSLAY,NODESS,NLIMBO)
C
C     READ IPDA FILE
C     ******************************************************************
      CHARACTER*24 ANAME(3)
      DIMENSION NPTCOLA(NODESS),NPTROWA(NODESS),
     *          NPTLAYA(NODESS)
      CHARACTER*200 LINE
C
      COMMON /SUBGRD/
     *  ISCOL1,ISCOL2,ISROW1,ISROW2,ISLAY1,ISLAY2,ISUBGD
C
      DATA ANAME(1) /' PARTICLE DENSITY--LAYER'/
      DATA ANAME(2) /'   PARTICLE DENSITY--ROW'/
      DATA ANAME(3) /'   PARTICLE DENSITY--COL'/
C
C
C     READ COMMENTS 
      CALL URDCOM(INIPDA,IOUTS,LINE)
C     READ IPDL PARAMETERS
      LLOC=1
      CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,NPMAX,R,IOUTS,INIPDA)
C      READ(INIPDA,*)  NPMAX
      WRITE(IOUTS,*) 'IPDA FILE PARAMETERS'
      WRITE(IOUTS,*) 'NPMAX   = ',NPMAX
C
      NSCR=NSCOL*NSROW
      DO 10 KS=1,NSLAY
C  KK IS NUMBER OF FLOW LAYER
      KK=KS+ISLAY1-1
      LOC=1+(KS-1)*NSCR
      CALL U2DINT(NPTLAYA(LOC),ANAME(1),NSROW,NSCOL,KK,INIPDA,IOUTS)
      CALL U2DINT(NPTROWA(LOC),ANAME(2),NSROW,NSCOL,KK,INIPDA,IOUTS)
      CALL U2DINT(NPTCOLA(LOC),ANAME(3),NSROW,NSCOL,KK,INIPDA,IOUTS)
  10  CONTINUE
C
C  LOOP TO CALCULATE NPMAX AND UPDATE DUE TO DIMENSION
      IF (NPMAX.EQ.0) MAXIPTS=0
      ILFLG=0
      IRFLG=0
      ICFLG=0
      DO 20 I=1,NODESS
	  NPTLAY=NPTLAYA(I)
	  NPTROW=NPTROWA(I)
	  NPTCOL=NPTCOLA(I)
C  CHECK FOR DIMENSION RESTRAINTS
        IF (NLAY.EQ.1.AND.NPTLAY.NE.1) THEN
          NPTLAYA(I)=1
          ILFLG=ILFLG+1
	  END IF
        IF (NROW.EQ.1.AND.NPTROW.NE.1) THEN
          NPTROWA(I)=1
          IRFLG=IRFLG+1
	  END IF
        IF (NCOL.EQ.1.AND.NPTCOL.NE.1) THEN
          NPTCOLA(I)=1
          ICFLG=ICFLG+1
	  END IF
C  TRACK MAXIMUM PTS IN CELL TO CALCULATE NPMAX BY DEFAULT
	  IF (NPMAX.EQ.0) MAXIPTS=
     *    MAX(MAXIPTS,NPTLAYA(I)*NPTROWA(I)*NPTCOLA(I))
C  TRACK INITIAL NUMBER OF PARTICLES IN THE GRID TO CALCULATE NLIMBO
        NPGRID=NPGRID+(NPTLAY*NPTROW*NPTCOL)
  20  CONTINUE
      IF(ILFLG.GT.0) WRITE(IOUTS,*) 'NLAY=1, RE-SET NPTLAY=1 AT ',
     *   ILFLG,' CELLS'
      IF(IRFLG.GT.0) WRITE(IOUTS,*) 'NROW=1, RE-SET NPTROW=1 AT ',
     *   IRFLG,' CELLS'
      IF(ICFLG.GT.0) WRITE(IOUTS,*) 'NCOL=1, RE-SET NPTCOL=1 AT ',
     *   ICFLG,' CELLS'
C
	IF (NPMAX.EQ.0) THEN
        NPMAX=2*NPGRID
        WRITE(IOUTS,*) 'NPMAX=0, USING DEFAULT CALCULATION'
        WRITE(IOUTS,*) 'MAXIPTS= ',MAXIPTS,'; NPMAX= ',NPMAX
      END IF
C  CALCULATE NLIMBO
      NLIMBO=500
      NTEMP=NPGRID/25
      IF(NTEMP.GT.NLIMBO) NLIMBO=NTEMP
C
      RETURN
      END
C
C
C  GWT1IPD1AL  ALLOCATE SPACE IN X ARRAY FOR IPDA AND IPDL
C***************************************************************
C
      SUBROUTINE GWT1IPD1AL(ISUM,NPMAX,IOUTS,IOUTG,
     *     LSPCOR,LSPROR,LSPLOR)
C
C***************************************************************
C
C  PLOR = PLORIG  = ORIGINAL LAYER LOCATION OF PARTICLE 
C  PROR = PRORIG  = ORIGINAL ROW LOCATION OF PARTICLE 
C  PCOR = PCORIG  = ORIGINAL COL LOCATION OF PARTICLE 
C
      ISOLD=ISUM
C
      LSPLOR=ISUM
      ISUM=ISUM+NPMAX
      LSPROR=ISUM
      ISUM=ISUM+NPMAX
      LSPCOR=ISUM
      ISUM=ISUM+NPMAX
c   mf2k allocates for isum-1, we use isum for placeholder on 
c   options that are "turned off", so chuck one more in here to avoid crash
	isum=isum+1
C
C6------PRINT THE AMOUNT OF SPACE USED BY THE IPDL OR IPDA PACKAGE.
      ISP=ISUM-ISOLD
      WRITE(IOUTG,101) ISP
      WRITE(IOUTS,101) ISP
  101 FORMAT(1X,I8,' ELEMENTS IN X ARRAY ARE USED BY IPDx')
C
C7------RETURN
      RETURN
      END
C
C
C  GWT1PTWT1AL  ALLOCATE SPACE IN X ARRAY FOR PARTICLE WEIGHTING ARRAYS
C***************************************************************
C
      SUBROUTINE GWT1PTWT1AL(ISUM,ISUMI,ISUMZ,LSCELV,LSPTWT,
     *        LSSUMW,LSSRCC,LSSRCV,LSBSRC,LSBSNK,
     *        LSBSOL,LSSGMS,LSSGWT,
     *        LSBFMS,LSBFWT,
     *        LSRESW,LSRESC,LSISRC,LSNPOR,
cgzh srcfix2
     *        LS_SRC,LS_SNK,LS_SOL,LSSOL,
     &        LSTOIN,LSTOOT,LSCOIN,LSCOOT,     
     *        NSROW,NSCOL,NSLAY,NPMAX,IOUTG,IOUTS)
C
C***************************************************************
C
C  CELV = CELVOL = VOLUME OF CELL 
C  PTWT = WEIGHT OF PARTICLE (CELVOL/NPCELL)
C  SUMW = SUMWT = SUM OF WEIGHTS IN CELL
C  SRCC = SRCAVC = AVERAGE SOURCE CONCENTRATION AT CELL
C  BSRC = BDYSRC = SOURCE FLUX FROM SUBGRID BOUNDARY
C  BSNK = BDYSNK = SINK FLUX FROM SUBGRID BOUNDARY
C  BSOL = BDYSOL = MASS FLUX FROM SOURCE AT SUBGRID BOUNDARY
C  SGMS = SUMSGMS = SUM OF SOLUTE FLUX ON PARTICLES LEAVING THE SUBGRID AT CELL
C  SGWT = SUMSGWT = SUM WEIGHTS OF PARTICLES LEAVING THE SUBGRID AT CELL
C  BFMS = SUMBFMS = SUM OF SOLUTE FLUX ON PARTICLES LEAVING VIA BOUNDARIES
C  BFWT = SUMBFWT = SUM WEIGHTS OF PARTICLES LEAVING VIA BOUNDARIES
C  RESW = RESIDWT = DISCHARGE NOT ACCOUNTED FOR ON PARTICLES FROM LAST MOVE
C  RESC = RESIDC = CONCENTRATION OF PTS THAT LEFT THE SUBGRID BUT WEREN'T ACCOUNTED FOR
C  ISRC = ISRCID = LOCATOR FOR STRONG SOURCES FOR PARTICLE LIST
C  _SRC = SS_SRC = SOURCE FLUX INTO A STRONG SOURCE FROM ANOTHER STRONG SOURCE
C  _SNK = SS_SNK = SINK FLUX OUT OF A STRONG SOURCE INTO ANOTHER STRONG SOURCE
C  _SOL = SS_SOL = MASS SRC FLUX OUT OF A STRONG SOURCE INTO ANOTHER STRONG SOURCE
C  SOL =    SOL =  MASS FROM BDY AND SRCS
C
C     ******************************************************************
C     ALLOCATE ARRAY STORAGE FOR SOLUTE-TRANSPORT PACKAGE
C     ******************************************************************
C
      INCLUDE 'ptwt.inc'
C
C SKIP IF WEIGHTING IS TURNED OFF
      IF(PTWTON.EQ.0) THEN
        LSCELV=1
        LSPTWT=1
        LSSUMW=1
	  LSSRCC=1
        LSSRCV=1
	  LSBSRC=1
	  LSBSNK=1
        LSBSOL=1
	  LSSGMS=1
	  LSSGWT=1
	  LSBFMS=1
	  LSBFWT=1
	  LSRESW=1
	  LSRESC=1
        LSISRC=1
        LSNPOR=1
        LS_SRC=1
        LS_SNK=1
        LS_SOL=1
        LSSOL=1
        LSTOIN=1
	  LSTOOT=1
	  LSCOIN=1
	  LSCOOT=1     
	  RETURN
      END IF
C4------COMPUTE DIMENSIONS FOR ARRAYS.
      NSRC=NSROW*NSCOL
      ISSIZ=NSRC*NSLAY
C
C  POINTERS TO DATA IN THE X an IX ARRAY
      ISOLD=ISUM
      ISOLDI=ISUMI
C  MOCWT DATA
      LSCELV=ISUMZ
      ISUMZ=ISUMZ+ISSIZ
cgzh debug double ptwt + sumwt
c      LSPTWT=ISUM
c      ISUM=ISUM+NPMAX
c      LSSUMW=ISUM
c      ISUM=ISUM+ISSIZ
cgzh debug make double by using Z array
      LSPTWT=ISUMZ
      ISUMZ=ISUMZ+NPMAX
      LSSUMW=ISUMZ
      ISUMZ=ISUMZ+ISSIZ
cgzh debug
      LSSRCC=ISUM
      ISUM=ISUM+ISSIZ
      LSSRCV=ISUM
      ISUM=ISUM+ISSIZ
	LSBSRC=ISUM
      ISUM=ISUM+ISSIZ
	LSBSNK=ISUM
      ISUM=ISUM+ISSIZ
      LSBSOL=ISUM
      ISUM=ISUM+ISSIZ
cgzh debug double sumsgwt + sumsgms + residwt
c      LSSGMS=ISUM
c      ISUM=ISUM+ISSIZ
c      LSSGWT=ISUM
c      ISUM=ISUM+ISSIZ
c      LSRESW=ISUM
c      ISUM=ISUM+ISSIZ
	LSSGMS=ISUMZ
      ISUMZ=ISUMZ+ISSIZ
	LSSGWT=ISUMZ
      ISUMZ=ISUMZ+ISSIZ
	LSBFMS=ISUMZ
      ISUMZ=ISUMZ+ISSIZ
	LSBFWT=ISUMZ
      ISUMZ=ISUMZ+ISSIZ
	LSRESW=ISUMZ
      ISUMZ=ISUMZ+ISSIZ
	LSRESC=ISUM
      ISUM=ISUM+ISSIZ
cgzh srcfix
      LSISRC=ISUMI
      ISUMI=ISUMI+ISSIZ
      LSNPOR=ISUMI
      ISUMI=ISUMI+ISSIZ
cgzh srcfix2
      LS_SRC=ISUM
      ISUM=ISUM+ISSIZ
      LS_SNK=ISUM
      ISUM=ISUM+ISSIZ
      LS_SOL=ISUM
      ISUM=ISUM+ISSIZ
      LSSOL=ISUM
      ISUM=ISUM+ISSIZ
      LSTOIN=ISUMZ
	ISUMZ=ISUMZ+ISSIZ
	LSTOOT=ISUMZ
	ISUMZ=ISUMZ+ISSIZ
	LSCOIN=ISUMI
	ISUMI=ISUMI+ISSIZ*6
	LSCOOT=ISUMI
	ISUMI=ISUMI+ISSIZ*6     
c
c   mf2k allocates for isum-1, we use isum for placeholder on 
c   options that are "turned off", so chuck one more in here to avoid crash
	isum=isum+1
	isumi=isumi+1
C
C6------PRINT THE AMOUNT OF SPACE USED BY THE MOCWT PACKAGE.
      ISP=ISUM-ISOLD
      WRITE(IOUTG,101) ISP
      WRITE(IOUTS,101) ISP
  101 FORMAT(1X,I8,' ELEMENTS IN X ARRAY ARE USED BY MOCWT')
C7------PRINT AMOUNT OF SPACE USED IN IX ARRAY.
      ISPI=ISUMI-ISOLDI
      WRITE(IOUTG,6) ISPI
      WRITE(IOUTS,6) ISPI
    6 FORMAT(1X,I8,' ELEMENTS IN IX ARRAY ARE USED BY MOCWT')
C
C7------RETURN
      RETURN
      END
C
C
C  SMOC1IPD  
C  GENERATE INITIAL PARTICLE DISTRIBUTION (IPDA AND IPDL PACKAGES)
C     ***************************************************************
C
      SUBROUTINE SMOC1IPD(PC,PR,PL,PCONC,CONC,NPCELL,IBOUND,
     *     PTWT,PCORIG,PRORIG,PLORIG,NPTLAYA,NPTROWA,NPTCOLA,IDIM,
     *     NCOL,NROW,NLAY,NSCOL,NSROW,NSLAY,NPMAX,IOUTS,NP,LIMBO,NLIMBO,
     *     WTFAC)
C
C     ***************************************************************
C
C     GENERATE PARTICLE POSITIONS
C
cgzh debug double ptwt
      DOUBLE PRECISION PTWT
      DIMENSION PC(NPMAX),PR(NPMAX),PL(NPMAX),PCONC(NPMAX),
     *   CONC(NSCOL,NSROW,NSLAY),NPCELL(NSCOL,NSROW,NSLAY),PTWT(NPMAX)
cgzh varpt
      DIMENSION PCORIG(NPMAX),PRORIG(NPMAX),PLORIG(NPMAX)
      DIMENSION NPTCOLA(NSCOL,NSROW,NSLAY),NPTROWA(NSCOL,NSROW,NSLAY),
     *          NPTLAYA(NSCOL,NSROW,NSLAY),WTFAC(NSCOL,NSROW,NSLAY)
      DIMENSION IBOUND(NCOL,NROW,NLAY),LIMBO(NLIMBO)
C
      COMMON /GWT/ CDEL,RDEL,CNOFLO,CELDIS,FZERO,NZCRIT
      COMMON /SUBGRD/
     *  ISCOL1,ISCOL2,ISROW1,ISROW2,ISLAY1,ISLAY2,ISUBGD
C
C     ***************************************************************
C  INITIALIZE PARTICLE ARRAYS
      DO 5 IP=1,NPMAX
        PC(IP)=0.0
        PR(IP)=0.0
        PL(IP)=0.0
        PCONC(IP)=0.0
   5  CONTINUE
cgzh varpt 
      NACTIV=0
      DO 10 KS=1,NSLAY
	DO 10 IS=1,NSROW
	DO 10 JS=1,NSCOL
        NPTCOL=NPTCOLA(JS,IS,KS)
        NPTROW=NPTROWA(JS,IS,KS)
        NPTLAY=NPTLAYA(JS,IS,KS)
C  SKIP NO-FLOW CELLS
        K=KS+ISLAY1-1
        I=IS+ISROW1-1
        J=JS+ISCOL1-1
        IF(IBOUND(J,I,K).EQ.0) GO TO 10
        NACTIV=NACTIV+1
        CALL ADDPTSVAR(PC,PR,PL,PCONC,CONC(JS,IS,KS),
     *          NPCELL,PCORIG,PRORIG,PLORIG,
     *          PTWT,0.D0,
     *          NSCOL,NSROW,NSLAY,
     *          NPMAX,NPTCOL,NPTROW,NPTLAY,
     *          JS,IS,KS,
     *          IOUTS,NP,IDIM,WTFAC)
  10  CONTINUE
C     ---SET UP LIMBO ARRAY---
      DO 20 IN=1,NLIMBO
   20   LIMBO(IN)=0
      WRITE(IOUTS,500) NP
  500 FORMAT(/,' TOTAL NUMBER OF PARTICLES GENERATED =',I10)
      NZCRIT=INT(FZERO*NACTIV)
      WRITE(IOUTS,501) NACTIV
  501 FORMAT(' TOTAL NUMBER OF ACTIVE NODES (NACTIV) =',I10)
      WRITE(IOUTS,502) NZCRIT
  502 FORMAT(' MAX. NUMBER OF CELLS THAT CAN BE VOID OF '
     1       ,'PARTICLES (NZCRIT) = ',I6/5X,
     2       '(IF NZCRIT EXCEEDED, PARTICLES ARE REGENERATED)')
C
C     ****************************************************************
      RETURN
C     ****************************************************************
      END
C
C
C    CALCULATE INITIAL PARTICLE WEIGHTS 
C     ******************************************************************
C
      SUBROUTINE PTWT1INITWT(IBOUND,PC,PR,PL,NPCELL,CELVOL,PTWT,SUMWT,
     *  NCOL,NROW,NLAY,NSCOL,NSROW,NSLAY,NPMAX,NP,IOUTS)
C
C     ******************************************************************
C     DETERMINE INITIAL PARTICLE VOLUMES
C     ******************************************************************
cgzh debug double ptwt
      DOUBLE PRECISION PTWT,FACTORM
cgzh debug  sumvol
      DOUBLE PRECISION CELVOL
      DOUBLE PRECISION SUMVOL
      DOUBLE PRECISION SUMWT
C      
	DIMENSION PC(NPMAX),PR(NPMAX),PL(NPMAX),
     *   NPCELL(NSCOL,NSROW,NSLAY)
      DIMENSION IBOUND(NCOL,NROW,NLAY)
	DIMENSION CELVOL(NSCOL,NSROW,NSLAY),PTWT(NPMAX),
     * SUMWT(NSCOL,NSROW,NSLAY)
C
      COMMON /SUBGRD/
     *  ISCOL1,ISCOL2,ISROW1,ISROW2,ISLAY1,ISLAY2,ISUBGD
      REAL R,C,L
cgzh debug
c      write(iouts,*) 
c      write(iouts,*) 'Initial particle weights'
c      write(iouts,*) 
      SUMVOL=0.0
      SUMWT=0.0
      DO 10 IP=1,NP
C       INITIALIZE
        PTWT(IP)=0.0
        C=PC(IP)
C       SKIP PARTICLE IF C COORDINATE IS ZERO
        IF(C.LE.0.0D0) GO TO 10
C       COMPUTE LOCATION (PC IN FLOW GRID COORDINATES)
        J=INT(C+0.5D0)
        JS=J-ISCOL1+1
        R=PR(IP)
C       R-COORDINATE MAY BE NEGATIVE AS A FLAG FOR MOVE ROUTINE
        IF(R.LT.0.0D0) THEN
         R=-R
        END IF
        I=INT(R+0.5D0)
        IS=I-ISROW1+1
        L=PL(IP)
        K=INT(L+0.5D0)
        KS=K-ISLAY1+1
C       COMPUTE PARTICLE WEIGHT = FRACTIONAL VOLUME = CELVOL/NPCELL
cgzh debug output
        FACTORM=1.D0/DBLE(NPCELL(JS,IS,KS))
cgzh debug
      if(js.eq.4.and.is.eq.3.and.ks.eq.1) then
      continue
	endif
        PTWT(IP)=CELVOL(JS,IS,KS)*FACTORM
c        DBTEMP=CELVOL(JS,IS,KS)/REAL(NPCELL(JS,IS,KS))
c        SNGTEMP=DBTEMP
c        SUMVOL3=SUMVOL3+DBTEMP
c        SUMVOL4=SUMVOL4+SNGTEMP
c        PTWT(IP)=CELVOL(JS,IS,KS)/REAL(NPCELL(JS,IS,KS))
        SUMVOL=SUMVOL+PTWT(IP)
        SUMWT(JS,IS,KS)=SUMWT(JS,IS,KS)+PTWT(IP)
cgzh debug output
c	 write(iouts,100) IP,js,is,PTWT(IP)
  10  CONTINUE
c 100  FORMAT('Particle ',I5,' in (C,R) ',I3,', ',I3,' = ',G10.4)
      write(iouts,*) 
	write(iouts,*) 'Cum. ptwt at initialization = ',SUMVOL
C
      DO 3102 KS=1,NSLAY
      DO 3102 IS=1,NSROW
      DO 3102 JS=1,NSCOL
	 IF(CELVOL(JS,IS,KS).EQ.0.0) GO TO 3102
	 ERRRATIO=SUMWT(JS,IS,KS)/CELVOL(JS,IS,KS)
       RATIOLIMIT=0.95
       IF(ERRRATIO.LT.RATIOLIMIT) THEN
	    WRITE (IOUTS,*) 'init PTWTs/CELVOL= ',ERRRATIO,' (too low)'
	    WRITE (IOUTS,*) 'CHECK PTS IN CELL ',JS,IS,KS
	 END IF
 3102 CONTINUE

c	write(iouts,*) 'DBLE Cum. ptwt at initialization = ',SUMVOL3
c	write(iouts,*) 'SNGLE Cum. ptwt at initialization = ',SUMVOL4
C
C	
      RETURN
	END
C
C
C  PTWT1UP  UPDATE PARAMETERS NEEDED FOR PARTICLE WEIGHTING SCHEME
C
C     ******************************************************************
C
      SUBROUTINE PTWT1UP(IBOUND,THCK,POR,
     *  CELVOL,IGENPT,PTWT,
     *  VC,VR,VL,RF,SRCFLO,SNKFLO,BDYSRC,NPTPND,NPMAX,
     *  IPTID,PNEWC,PNEWR,PNEWL,NEWPTS,
     *  NCOL,NROW,NLAY,NSCOL,NSROW,NSLAY,IOUTS,
     *  KKPER,ISS,SUMWT,NPCELL,
     *  PC,PR,PL,PCONC,LAYHDT,NP,
cgzh varpt
     *  INIPDL,INIPDA,PCORIG,PRORIG,PLORIG,NPTLAYA,NPTROWA,NPTCOLA,IDIM,
cgzh ssfix
     *  CONC,LIMBO,NLIMBO,MULTSS,SBVL,NIUNIT,
     *  REMCRIT,GENCRIT,SRCDCY,
cgzh mnw
     &  SRCMNW,SNKMNW,INMNW,
cgzh srcfix
     &  ISRCID,MAXSRC,NPCELLMAX,NPORIG,IPERGWT,WTFAC,
cgzh et
     *  INEVT,NEVTOP,IEVT,EVTFLO,ISRCFIX,
c RBW sorption     
     *  JRF)
C
C     ******************************************************************
C        CALCULATE PORE VOLUME AT EACH CELL (CELVOL)
C        CALCULATE STRONG SOURCE FLAG AT EACH CELL (IGENPT)
C        ON PARTICLES, ACCOUNT FOR CHANGE IN CELL 
C          VOLUME DUE TO NEW STEADY STATE PERIOD (CALL PTWT1SSUP)
C     ******************************************************************
C TEMPORARY ARRAYS
cgzh debug double ptwt, sumwt
      USE VBALMOD 
      DOUBLE PRECISION CELVOL
      DOUBLE PRECISION PTWT,SUMWT,DELVOL,SBVL
      ALLOCATABLE DELVOL(:,:,:),VOLOLD(:,:,:)
      DIMENSION IBOUND(NCOL,NROW,NLAY),WTFAC(NSCOL,NSROW,NSLAY)
      DIMENSION THCK(NSCOL,NSROW,NSLAY),POR(NSCOL,NSROW,NSLAY),
     *  CELVOL(NSCOL,NSROW,NSLAY),IGENPT(NSCOL,NSROW,NSLAY),
     *  PTWT(NPMAX),
     *  VC(NSCOL+1,NSROW,NSLAY),VR(NSCOL,NSROW+1,NSLAY),
     *  VL(NSCOL,NSROW,NSLAY+1),RF(NSCOL,NSROW,NSLAY),
     *  SRCFLO(NSCOL,NSROW,NSLAY),SNKFLO(NSCOL,NSROW,NSLAY),
     *  BDYSRC(NSCOL,NSROW,NSLAY),
     *  PC(NPMAX),PR(NPMAX),PL(NPMAX),PCONC(NPMAX),
     *  LAYHDT(NLAY),SUMWT(NSCOL,NSROW,NSLAY),
     *  NPCELL(NSCOL,NSROW,NSLAY),IPTID(NPMAX),
     *  PNEWC(NEWPTS),PNEWR(NEWPTS),PNEWL(NEWPTS)
cgzh varpt
      DIMENSION PCORIG(NPMAX),PRORIG(NPMAX),PLORIG(NPMAX),
     *  NPTCOLA(NSCOL,NSROW,NSLAY),NPTROWA(NSCOL,NSROW,NSLAY),
     *  NPTLAYA(NSCOL,NSROW,NSLAY)
cgzh ssfix
      DIMENSION CONC(NSCOL,NSROW,NSLAY),LIMBO(NLIMBO),SBVL(6,NIUNIT),
     * NPORIG(NSCOL,NSROW,NSLAY)
cgzh mnw
      DIMENSION SRCMNW(NSCOL,NSROW,NSLAY),SNKMNW(NSCOL,NSROW,NSLAY)
cgzh srcfix
      DIMENSION ISRCID(NSCOL,NSROW,NSLAY)
cgzh et
      DIMENSION EVTFLO(NSCOL,NSROW,2),IEVT(NROW,NCOL)             
C
      COMMON /GWT/ CDEL,RDEL,CNOFLO,CELDIS,FZERO,NZCRIT
      COMMON /SUBGRD/
     *  ISCOL1,ISCOL2,ISROW1,ISROW2,ISLAY1,ISLAY2,ISUBGD
      LOGICAL REGENERATE
C
      ALLOCATE(DELVOL(NSCOL,NSROW,NSLAY),VOLOLD(NSCOL,NSROW,NSLAY))
C  REMCRIT (REMOVAL CRITERIA FOR SINKS: 
C    FRACTION OF INITIAL-PARTICLE-WEIGHT PARTICLE CAN BE BEFORE BEING REMOVED)
C  GENCRIT (CRITERIA FOR STRONG SOURCE CELLS:
C    IF RATIO OF WHAT IS COMING FROM SOURCE TO WHAT IS LEAVING CELL ON FACES 
C    > CRITERIA, THEN SET AS STRONG SOURCE
cgzh debug  make these user-defined?
cgzh debug  vary gencrit by cell?
c      REMCRIT=0.2
c      REMCRIT=0.2
c      REMCRIT=0.25
c      GENCRIT=0.25
c      GENCRIT=0.05
c      GENCRIT=0.1
cgzh debug? output
c      write(iouts,*) 'REMCRIT=',REMCRIT
c      write(iouts,*) 'GENCRIT=',GENCRIT
cgzh debug  flag to check delvol.ne.0
      IVFLAG=0
      SUMVOL=0.0
      MAXSRC=0
      NPCELLMAX=0
      ISRCID=0
      icount=0
C
C  CALCULATE PORE VOLUME OF CELL (THCK*AREA*POROSITY)
       CALL GWT1BAS6CV(CELVOL,THCK,POR,IBOUND,
     *   NSCOL,NSROW,NSLAY,NCOL,NROW,NLAY)
C
      DO 10 KS=1,NSLAY
       K=KS+ISLAY1-1
      DO 10 IS=1,NSROW
       I=IS+ISROW1-1
      DO 10 JS=1,NSCOL
       J=JS+ISCOL1-1
C  SKIP NO-FLOW CELLS
       IF(IBOUND(J,I,K).EQ.0) GO TO 10
       VOLOLD(JS,IS,KS)=CELVOL(JS,IS,KS)
cgzh debug
       SUMVOL=SUMVOL+CELVOL(JS,IS,KS)
C  FOR SUBSEQUENT STEADY PERIODS, SAVE DIFFERENCE IN CELL 
C  VOLUME IN CONVERTIBLE CELLS (APPLIED TO PARTICLES VIA REGEN BELOW)
C  DELVOL: NEGATIVE IS LESS VOLUME, POSITIVE IS MORE VOLUME
       IF(KKPER.GT.IPERGWT.AND.ISS.EQ.1.AND.LAYHDT(K).NE.0) THEN
         DELVOL(JS,IS,KS)=CELVOL(JS,IS,KS)-VOLOLD(JS,IS,KS)
C  FLAG AT LEAST ONE CELL WITH NEW VOLUME
         IF (DELVOL(JS,IS,KS).NE.0.0) IVFLAG=1
       END IF
cgzh varpt
       IF(INIPDL.GT.0.OR.INIPDA.GT.0) THEN
        NPTLAY=NPTLAYA(JS,IS,KS)
        NPTROW=NPTROWA(JS,IS,KS)
        NPTCOL=NPTCOLA(JS,IS,KS)
	  NPTPND=NPTLAY*NPTROW*NPTCOL
       END IF
C  INITIALIZE IGENPT
       IGENPT(JS,IS,KS)=0
C  SET NPORIG
       IF(KKPER.EQ.IPERGWT) NPORIG(JS,IS,KS)=NPCELL(JS,IS,KS)
C  CALCULATE Q FROM EXTERNAL SOURCES AND SINKS
C  INCLUDE SUBGRID BOUNDARY FACE FLOWS FOR SOURCE,
C    BUT ONLY COUNT EXTERNAL SINKS (SNKFLO); COUNT BDYSNK BELOW IN FACE FLUXES 
       SRCNET=SRCFLO(JS,IS,KS)+BDYSRC(JS,IS,KS)+SNKFLO(JS,IS,KS)
      IF(INMNW.GT.0)
     * SRCNET=SRCNET+SRCMNW(JS,IS,KS)+SNKMNW(JS,IS,KS)
C  IF ET IS ACTIVE, GET ETFLO
      IF(INEVT.GT.0) THEN
        KEV=EVTFLO(JS,IS,2)
        IF(KEV.EQ.K) ETFLO=EVTFLO(JS,IS,1)
        SRCNET=SRCNET+ETFLO
      END IF
C  SKIP IF NO NET SOURCE TO CELL
       IF(SRCNET.LE.0.0) GO TO 10
C  SUMQOT=SUM OF ALL FLOWS EXITING CELL ACROSS FACES (POSITIVE)
       SUMQOT=0.0                                                           
C  IF ONLY ONE COLUMN IN FLOW GRID, SKIP TO ROWS
       IF (NCOL.EQ.1) GO TO 20
C  COLUMN-WISE FLUXES
C  LEFT-SIDE FACE: NEGATIVE VALUE SIGNIFIES EXITING CELL TO LEFT
       Q=VC(JS,IS,KS)
       IF (Q.LT.0.0) SUMQOT=SUMQOT-Q                                          
C  RIGHT-SIDE FACE (JS+1): POSITIVE VALUE SIGNIFIES EXITING CELL TO RIGHT
       Q=VC(JS+1,IS,KS)                                   
       IF (Q.GT.0.0) SUMQOT=SUMQOT+Q                                          
  20   IF (NROW.EQ.1) GO TO 30
C  ROW-WISE FLUXES
       Q=VR(JS,IS,KS)
       IF (Q.LT.0.0) SUMQOT=SUMQOT-Q                                          
       Q=VR(JS,IS+1,KS)                                  
       IF (Q.GT.0.0) SUMQOT=SUMQOT+Q                                          
  30   IF (NLAY.EQ.1) GO TO 40
C  LAYER-WISE FLUXES
       Q=VL(JS,IS,KS)
       IF (Q.LT.0.0) SUMQOT=SUMQOT-Q                                          
       Q=VL(JS,IS,KS+1)
       IF (Q.GT.0.0) SUMQOT=SUMQOT+Q                                          
C 
Ccgzh debug  NOTHING LEAVING CELL (POSSIBLE IF SRCNET>0???)
cgzh this is possible if flow solution is bad
  40   IF (SUMQOT.LE.0.0) THEN
         write(iouts,*) '***WARNING***: SUMQOT <= 0, SRCNET > 0 AT:',
     &      JS,IS,KS
         write(iouts,*) 'SUMQOT,SRCNET',SUMQOT,SRCNET
         write(iouts,*) 'SRCFLO,BDYSRC,SNKFLO',
     & SRCFLO(JS,IS,KS),BDYSRC(JS,IS,KS),SNKFLO(JS,IS,KS)
         write(iouts,*) 'CHECK ACCURACY OF FLOW SOLUTION '
       ELSE
C  PARTICLES ARE ADDED AT STRONG SOURCES (IGENPT=1) OR WHERE SPECIFIED IN VBAL
         REGENERATE = .FALSE.
         IF((SRCNET/SUMQOT).GT.GENCRIT) THEN
           REGENERATE = .TRUE.
         ELSE IF ((ISRCFIX.GT.0).AND.ALLOCATED(VBAL)) THEN
           IF (VBAL(JS,IS,KS).EQ.1) THEN
             REGENERATE = .TRUE.
           ENDIF
         ENDIF
         IF(REGENERATE) THEN
cgzh orig line         IF((SRCNET/SUMQOT).GT.GENCRIT) THEN
	     IGENPT(JS,IS,KS)=1
cgzh debug?  or clean up output
           icount=icount+1
c           write(iouts,*) 'Strong source (IGENPT = 1) at:',js,is,ks
c           write(iouts,*) 'SRCNET,SUMQOT=',SRCNET,SUMQOT
c           write(iouts,*) 'SRCNET/SUMQOT=',SRCNET/SUMQOT
cgzh srcfix
C  FLAG LOCATIONS OF STRONG SOURCES
c no need to allocate maxsrc and npcellmax unless ISRCFIX is on
          IF(ISRCFIX.GT.0) THEN
           MAXSRC=MAXSRC+1
           ISRCID(JS,IS,KS)=MAXSRC
           IF(NPCELL(JS,IS,KS).GT.NPCELLMAX) NPCELLMAX=NPCELL(JS,IS,KS)
cgzh debug clark
           if(npcellmax.gt.1000) then
	       write(iouts,*) 'npcellmax,js,is,ks',npcellmax,js,is,ks
c	stop
	     endif
	    END IF
	   END IF
	 END IF
  10  CONTINUE
cgzh srcfix
c
c      NPCELLMAX=NPCELLMAX*20
      NPCELLMAX=NPCELLMAX*2+20
cgzh debug output
      write(iouts,*) 'Number of strong source cells=',icount
      write(iouts,*) 
      write(iouts,*) 'Npcellmax=',npcellmax

cgzh debug output
c      write(iouts,*) 
c      write(iouts,*) 'CELL VOLUMES'
c      DO 100 KS=1,NSLAY
c      DO 100 IS=1,NSROW
c	 write(iouts,*) (CELVOL(JS,IS,KS),JS=1,NSCOL) 
c 100  CONTINUE
      write(iouts,*) 
      write(iouts,*) 'Cum. cell vol = ',SUMVOL
CMOCWT
C  FOR SUBSEQUENT STEADY STATE PERIODS, UPDATE PARTICLE VOLUMES TO
C    ACCOUNT FOR DIFFERENCE IN SATURATED THICKNESS
c   un-implementing mass conservative approach
!   reinstating mass conservative
! RBW      go to 444
c
      IF (KKPER.GT.IPERGWT.AND.ISS.EQ.1.AND.IVFLAG.EQ.1) THEN
  	  WRITE(*,*) 'CALL PTWT1SSUP'
cgzh debug output
        WRITE(IOUTS,*) '***WARNING***'
        WRITE(IOUTS,*) 'CHANGE IN VOLUME DUE TO NEW SS STRESSES ',
     *  'BUT SOLUTE MASS UNCHANGED: '
        WRITE(IOUTS,*) 'PARTICLE CONCENTRATIONS MAY BE AFFECTED'
c	  
	  CALL PTWT1SSUP(DELVOL,VOLOLD,CELVOL,
     *  PC,PR,PL,PCONC,LAYHDT,IBOUND,
     *  SUMWT,PTWT,
     *  NPCELL,IPTID,
     *  PNEWC,PNEWR,PNEWL,NEWPTS,
     *  NSCOL,NSROW,NSLAY,NPMAX,
     *  NCOL,NROW,NLAY,IOUTS,NP,
cgzh varpt
     *  INIPDL,INIPDA,PCORIG,PRORIG,PLORIG,NPTLAYA,NPTROWA,NPTCOLA,IDIM)
      ENDIF     
c
c
cgzh new implementation: restart particles if there was a change in volume
cgzh ssfix
  444 Continue
      GoTo 445
cgzh debug return skips ssfix
c      RETURN 
c      IF (KKPER.GT.1.AND.ISS.EQ.1.AND.IVFLAG.EQ.1) THEN
c this replaces logic above, since need to do even if this sp happens to be trans
c      IF(MULTSS.EQ.1) THEN
c replacing the replacement with original, *don't* need to call this each TS in 
c a TR SP
      IF (KKPER.GT.1.AND.ISS.EQ.1.AND.IVFLAG.EQ.1) THEN
cgzh debug output
      write(iouts,*) 
      write(iouts,*) '***STARTING OVER: ***'
      write(iouts,*) 'ZERO OUT MB, REGEN PTS'
      write(iouts,*) 
CGWT    REINITIALIZE SOURCE-TERM DECAY ACCUMULATOR 
        SRCDCY=0.0
C
CGWT----SAVE MASS BALANCE ACCUMULATORS IN EXTRA SBVL SLOTS
C
C       SAVE PRESENT MASS FOR COMPARISON AFTER REGEN
        STORMASS=SBVL(4,1)
CGWT    SAVE INITIAL MASS FOR NEW STRESS PERIOD
cgzh this will be calculated from regenerated pts
c          SBVL(1,1)=SBVL(4,1)
c          SBVL(1,2)=SBVL(2,2)
CGWT----RESET MASS BALANCE ACCUMULATORS
          SBVL(2,1)=0.0
          SBVL(2,2)=0.0
          DO 900 I=3,NIUNIT
          DO 900 J=1,4
            SBVL(J,I)=0.0
  900     CONTINUE
C ONLY REGEN PARTICLES IF THERE WAS A CHANGE IN VOLUME
c        IF (IVFLAG.EQ.1) THEN
C         CALL SMOC5GP TO GENERATE INITIAL PARTICLES
          IF(INIPDL.EQ.0.AND.INIPDA.EQ.0) THEN
            CALL SMOC5GP(PC,PR,PL,PCONC,CONC,
     *       IPTID,NPCELL,IBOUND,
     *       PNEWC,PNEWR,PNEWL,LIMBO,NCOL,NROW,NLAY,
     *       NSCOL,NSROW,NSLAY,NEWPTS,NPMAX,NLIMBO,
     *       IOUTS,NP,WTFAC)
          ELSE
C           GENERATE PARTICLES--IPDL OR IPDA
cgzh varpt
            CALL SMOC1IPD(PC,PR,PL,PCONC,CONC,NPCELL,IBOUND,
     *       PTWT,PCORIG,PRORIG,PLORIG,NPTLAYA,NPTROWA,NPTCOLA,IDIM,
     *       NCOL,NROW,NLAY,NSCOL,NSROW,NSLAY,NPMAX,IOUTS,NP,LIMBO,
     *       NLIMBO,WTFAC)        
          END IF
C         DETERMINE INITIAL PARTICLE WEIGHTS 
          CALL PTWT1INITWT(IBOUND,PC,PR,PL,NPCELL,CELVOL,PTWT,SUMWT,
     *     NCOL,NROW,NLAY,NSCOL,NSROW,NSLAY,NPMAX,NP,IOUTS)
C         CALCULATE NEW "INITIAL" MASS
          CALL SMOC6IM(IBOUND,CONC,THCK,RF,
     *     POR,SBVL,NSCOL,NSROW,NSLAY,NCOL,NROW,NLAY,IOUTS,JRF,NIUNIT)
C         REPORT CHANGE IN MASS THAT WILL NOT BE ACCOUNTED FOR IN MASS BALANCE
cgzh spruce this up
C         DIFFMASS > 0 : INCREASE IN MASS
C         DIFFMASS < 0 : DECREASE IN MASS
          DIFFMASS=SBVL(1,1)-STORMASS
          IF(DIFFMASS.NE.0.0) THEN
           WRITE(IOUTS,*) '***WARNING***'
           WRITE(IOUTS,*) 'CHANGE IN MASS DUE TO NEW SS STRESSES '
           WRITE(IOUTS,*) 'THIS DIFFERENCE IN MASS NOT ACCOUNTED FOR ',
     *       'IN SUBSEQUENT MASS BALANCE CALCULATIONS'
           WRITE(IOUTS,*) 'STORED MASS AT END OF PREVIOUS STRESS PERIOD
     * = ',STORMASS
           WRITE(IOUTS,*) 'CHANGE IN STORED MASS = ',DIFFMASS
          END IF
c        END IF
C        ENDIF: CHANGE IN VOLUME (old)
C
      END IF
  445 Continue      
C     ENDIF: SS SP > 1 and CHANGE IN VOLUME 
C  RELEASE MEMORY
      DEALLOCATE(DELVOL,VOLOLD)
C
      RETURN
	END
C
C
C
C  PTWT1SSUP  CHANGE VOLUME AND CONC OF PARTICLES DUE TO
C               CHANGE IN CELL VOLUME IN NEW STEADY STATE PERIOD
C*************************************************************************
C
      SUBROUTINE PTWT1SSUP(DELVOL,VOLOLD,CELVOL,
     *  PC,PR,PL,PCONC,LAYHDT,IBOUND,
     *  SUMWT,PTWT,
     *  NPCELL,IPTID,
     *  PNEWC,PNEWR,PNEWL,NEWPTS,
     *  NSCOL,NSROW,NSLAY,NPMAX,
     *  NCOL,NROW,NLAY,IOUTS,NP,
cgzh varpt
     *  INIPDL,INIPDA,PCORIG,PRORIG,PLORIG,NPTLAYA,NPTROWA,NPTCOLA,IDIM)
C
C*************************************************************************
C
C  CHANGE WEIGHT AND CONC OF PARTICLES DUE TO NEW SS STRESS PERIOD
C
C TEMPORARY ARRAYS
cgzh debug double ptwt, sumwt
      DOUBLE PRECISION CELVOL
      DOUBLE PRECISION PTWT,SUMWT,DELVOL
      ALLOCATABLE TEMPWT(:,:,:)
      DIMENSION
     *  IBOUND(NCOL,NROW,NLAY),LAYHDT(NLAY),
     *  PC(NPMAX),PR(NPMAX),PL(NPMAX),PCONC(NPMAX),
     *  SUMWT(NSCOL,NSROW,NSLAY),VOLOLD(NSROW,NSCOL,NSLAY),
     *  PTWT(NPMAX),DELVOL(NSCOL,NSROW,NSLAY),CELVOL(NSROW,NSCOL,NSLAY),
     *  NPCELL(NSCOL,NSROW,NSLAY),IPTID(NPMAX),
     *  PNEWC(NEWPTS),PNEWR(NEWPTS),PNEWL(NEWPTS)
cgzh varpt
      DIMENSION PCORIG(NPMAX),PRORIG(NPMAX),PLORIG(NPMAX),
     *  NPTCOLA(NSCOL,NSROW,NSLAY),NPTROWA(NSCOL,NSROW,NSLAY),
     *  NPTLAYA(NSCOL,NSROW,NSLAY)
C
      COMMON /SUBGRD/
     *  ISCOL1,ISCOL2,ISROW1,ISROW2,ISLAY1,ISLAY2,ISUBGD
C
C     ****************************************************************
      ALLOCATE(TEMPWT(NSCOL,NSROW,NSLAY))
      TEMPWT = 0;
C     ---CHANGE VOLUME AND CONCENTRATION OF PARTICLES---
      DO 180 IP=1,NP
      IF(PC(IP).EQ.0.0) GO TO 180
      J=PC(IP)+0.5
      JS=J-ISCOL1+1
      I=ABS(PR(IP))+0.5
      IS=I-ISROW1+1
      K=PL(IP)+0.5
      KS=K-ISLAY1+1
C     ---UPDATE WEIGHT AND CONC. OF PTS. IN ACTIVE CONVERTIBLE CELLS---
      IF(IBOUND(J,I,K).NE.0.AND.LAYHDT(K).NE.0) THEN
        IF(DELVOL(JS,IS,KS).NE.0.0) THEN
C  POSITIVE DELVOL IS ADDITIONAL VOLUME
C  NEGATIVE DELVOL IS VOLUME TO BE REMOVED
	    IF(DELVOL(JS,IS,KS).LT.0.0) THEN
C  REMOVING WATER	    
! RBW            FRACSUMWT=0.95*SUMWT(JS,IS,KS)
! RBW            IF((ABS(DELVOL(JS,IS,KS))).GT.FRACSUMWT) THEN
C  IF REMOVING WATER, AND VOLUME TO BE REMOVED IS
C    95% OR MORE OF VOLUME ON ALL PARTICLES, REMOVE VOLUME AS RATIO OF
C    (VOLNEW/CELVOL) = RATIO OF REDUCTION IN VOLUME
C  THIS DOES NOT CONSERVE FLUID VOLUME
! RBW             FRACWT=(CELVOL(JS,IS,KS)/VOLOLD(JS,IS,KS))*DELVOL(JS,IS,KS)
! RBW            ELSE
C  IF REMOVING WATER, AND ENOUGH VOLUME, REMOVE RELATIVE WT FROM PTS
             IF(SUMWT(JS,IS,KS).GT.0.0) THEN
              FRACWT=(PTWT(IP)/SUMWT(JS,IS,KS))*DELVOL(JS,IS,KS)
             ELSE
              FRACWT=0.0
	       END IF
! RBW            END IF
          ELSE
C  IF ADDING WATER ADD TO EACH PT EQUALLY
           IF(NPCELL(JS,IS,KS).GT.0.0) THEN
            FRACWT=DELVOL(JS,IS,KS)/REAL(NPCELL(JS,IS,KS))
           ELSE
	      FRACWT=0.0
	     END IF
	    END IF
C  CALCULATE NEW PARTICLE CONCENTRATION 
cgzh debug  assume new water at zero C
cgzh debug  this could cause big errors if delvol large relative to sumwt
cgzh debug
c      write(iouts,*) 'Old concentration for particle',ip,' = ',pconc(ip)

C RBW When removing water, adding FRACWT to the particle weight could result in a 
C negative particle weight if the weight of the particles in the cell is less than 
C the change in fluid volume in the cell. In such cases, the particle weight is 
C set to zero. This does not conserve fluid volume but there is no way to conserve 
C fluid volume without ending up with negative particle weights.
          if (PTWT(IP)+FRACWT .LE. 0) then
       	    PCONC(IP)=0
	      TEMPWT(JS,IS,KS)=TEMPWT(JS,IS,KS)-PTWT(IP)
	      PTWT(IP)=0
          else
       	    PCONC(IP)=(PCONC(IP)*PTWT(IP))/(PTWT(IP)+FRACWT)
c      write(iouts,*) 'New concentration for particle',ip,' = ',pconc(ip)
	      PTWT(IP)=PTWT(IP)+FRACWT
	      TEMPWT(JS,IS,KS)=TEMPWT(JS,IS,KS)+FRACWT
	    endif
cgzh debug sumc (sum of mass) does not change
cgzh 
c
        END IF
      END IF
  180 CONTINUE
C
C  LOOP OVER CELLS TO ACCOUNT FOR CHANGE IN CELLS WITH NO PARTICLES
C  LOOP OVER CELLS TO UPDATE SUM OF WEIGHTS IN CELLS
      DO 2600 KS=1,NSLAY
       K=KS+ISLAY1-1
      DO 2600 IS=1,NSROW
       I=IS+ISROW1-1
      DO 2600 JS=1,NSCOL
       J=JS+ISCOL1-1
      IF(IBOUND(J,I,K).NE.0.AND.LAYHDT(K).NE.0) THEN
	  IF (NPCELL(JS,IS,KS).EQ.0) THEN
C  IF NO PARTICLES IN CELL AND INCREASE, ADD PARTICLES
C  SET CONCENTRATION OF NEW PARTICLES = 0.0
          IF(DELVOL(JS,IS,KS).GT.0.0) THEN
	      TEMC=0.0
cgzh debug
c            WRITE(IOUTS,*) 
c            WRITE(IOUTS,*)'Calling ADDPTS: NPCELL=0 in PTWT1SSUP.'
c            WRITE(IOUTS,*) 'Creating',NEWPTS-1,' new particles ',
c     *                     'at (js,is,ks):'
c            WRITE(IOUTS,*) js,is,ks
cgzh varpt 
            IF(INIPDL.EQ.0.AND.INIPDA.EQ.0) THEN
              CALL ADDPTS(PC,PR,PL,PCONC,TEMC,IPTID,NPCELL,
     *          IBOUND,PNEWC,PNEWR,PNEWL,
     *          PTWT,DELVOL(JS,IS,KS),
     *          NCOL,NROW,NLAY,NSCOL,NSROW,NSLAY,
     *          NEWPTS,NPMAX,
     *          JS,IS,KS,
     *          IOUTS,NP,WTFAC)
            ELSE
cgzh varpt 
cgzh get particle distribution for this cell
              NPTCOL=NPTCOLA(JS,IS,KS)
              NPTROW=NPTROWA(JS,IS,KS)
              NPTLAY=NPTLAYA(JS,IS,KS)
              CALL ADDPTSVAR(PC,PR,PL,PCONC,TEMC,
     *          NPCELL,PCORIG,PRORIG,PLORIG,
     *          PTWT,DELVOL(JS,IS,KS),
     *          NSCOL,NSROW,NSLAY,
     *          NPMAX,NPTCOL,NPTROW,NPTLAY,
     *          JS,IS,KS,
     *          IOUTS,NP,IDIM,WTFAC)
            END IF
C          TRACK AMOUNT ADDED BY THIS PROCESS
            TEMPWT(JS,IS,KS)=TEMPWT(JS,IS,KS)+DELVOL(JS,IS,KS)
	    ELSE
C  IF NO PARTICLES IN CELL AND DECREASE, PRINT WARNING
            WRITE(IOUTS,*) '***WARNING*** NPCELL = 0 AT: ',JS,IS,KS
		  WRITE(IOUTS,*) 'DECREASE IN CELL VOLUME DUE TO NEW STEADY',
     *      ' STRESS NOT ACCOUNTED FOR; FLUID VOLUME NOT CONSERVED'
          END IF
        END IF
C  ADD WEIGHTS AND MASS ALTERED TO "SUM" ARRAY
        SUMWT(JS,IS,KS)=SUMWT(JS,IS,KS)+TEMPWT(JS,IS,KS)
      END IF
C  
 2600	CONTINUE
C  RELEASE MEMORY
      DEALLOCATE(TEMPWT)
C     ****************************************************************
      RETURN
C     ****************************************************************
      END
C
C
C
C
C  PTWT1SRCC  CALCULATE COMPONENTS FOR AVERAGE SOURCE CONCENTRATION (SRCAVC)
C             USED FOR APPLYING SOURCE WITH WEIGHTED PARTICLE OPTION
C*************************************************************************
C
      SUBROUTINE PTWT1SRCC(SRCFLO,SRCSOL,BDYSRC,BDYSOL,SRCVOL,
     *        SRCAVC,RF,NSCOL,NSROW,NSLAY,DECAY,TIMV,SRCDCY,
     *        DKFO,DKFS,INDK,IDKFO,IDKFS,SOL)
C
      DOUBLE PRECISION DECAY
      DOUBLE PRECISION DCYFCT,DCYT,DCYT2
C
      DIMENSION SRCFLO(NSCOL,NSROW,NSLAY),SRCSOL(NSCOL,NSROW,NSLAY),
     *          BDYSRC(NSCOL,NSROW,NSLAY),BDYSOL(NSCOL,NSROW,NSLAY),
     *          SRCAVC(NSCOL,NSROW,NSLAY),RF(NSCOL,NSROW,NSLAY),
     *          SRCVOL(NSCOL,NSROW,NSLAY),SOL(NSCOL,NSROW,NSLAY)
      DIMENSION DKFO(NSCOL,NSROW,NSLAY),
     *    DKFS(NSCOL,NSROW,NSLAY)
C INITIALIZE 
      SRCAVC=0.
      SOL=0.
      SRCVOL=0.
      DCYT2=1.D0
C ONLY DECAY OVER 1/2 TIMV
      IF(DECAY.NE.0.D0) THEN
        DCYFCT=DBLE(TIMV)*DECAY
        DCYT2=DEXP(-DCYFCT*0.5D0)
      END IF
C LOOP OVER CELLS
      DO 30 KS=1,NSLAY
      DO 30 IS=1,NSROW
      DO 30 JS=1,NSCOL
C ONLY IF SOURCE AT THIS CELL
        IF(SRCFLO(JS,IS,KS).GT.0.OR.BDYSRC(JS,IS,KS).GT.0) THEN
C GET SPATIALLY-VARYING DECAY RATE
          IF(INDK.GT.0) THEN
            IF(IDKFO.EQ.1.OR.IDKFS.EQ.1) THEN
              TIMV2=TIMV*0.5
              CALL DK6DK(DCYT2,DKFO,DKFS,RF,TIMV2,
     *          IDKFO,IDKFS,
     *          JS,IS,KS,NSCOL,NSROW,NSLAY)
            END IF
          END IF 
C DECAY SOURCES (DCYT2=1.0 if no decay)
          SRCD=SRCSOL(JS,IS,KS)*DCYT2
          BDYD=BDYSOL(JS,IS,KS)*DCYT2
c include boundary source decayed (BDYD) in SRCDCY
c orig          SRCDCY=SRCDCY+(SRCD-SRCSOL(JS,IS,KS)+(BDYD-BDYSOL(JS,IS,KS)))
cgzh convert SRCDCY to mass by mult by time
          SRCDCY=SRCDCY+TIMV*
     &  (SRCD-SRCSOL(JS,IS,KS)+(BDYD-BDYSOL(JS,IS,KS)))
C and RETARD SOURCES
c          SRCDRF=SRCD/RF(JS,IS,KS)
c          BDYDRF=BDYD/RF(JS,IS,KS)
C
cgzh srcfix2
C    Moved definition of SRCAVC into move loop, defined each move due to MNW and SS_SRC
C    Now, just accumulate decayed mass flux in SRCSOL
c          SRCAVC(JS,IS,KS)=
c     *  (SRCD+BDYD)/(SRCFLO(JS,IS,KS)+BDYSRC(JS,IS,KS))
          SRCVOL(JS,IS,KS)=SRCFLO(JS,IS,KS)+BDYSRC(JS,IS,KS)
          SOL(JS,IS,KS)=SRCD+BDYD
        END IF
   30 CONTINUE
C
      RETURN
      END
C
C
C  SMOC5BYSRC   SUM FLUX AND SOLUTE FLUX ACROSS BOUNDARIES OF SUBGRID
C*************************************************************************
C
      SUBROUTINE SMOC5BYSRC(CTCFLO,LOCBDY,BDYSRC,BDYSOL,BDYSNK,
     *  CINFL,NCINFL,CINFLA,CINFLB,CINXY,
     *  NCOL,NROW,NLAY,NSCOL,NSROW,NSLAY,NFACES,IABOVE,IBELOW)
C
      DIMENSION CTCFLO(NFACES),LOCBDY(3,NFACES)
      DIMENSION BDYSRC(NSCOL,NSROW,NSLAY),BDYSOL(NSCOL,NSROW,NSLAY),
     *          BDYSNK(NSCOL,NSROW,NSLAY),CINFL(NCINFL)
cgzh cbdy
      DIMENSION CINFLA(NSCOL,NSROW),CINFLB(NSCOL,NSROW),
     * CINXY(NSCOL,NSROW,NSLAY)
C
      COMMON /SUBGRD/
     *  ISCOL1,ISCOL2,ISROW1,ISROW2,ISLAY1,ISLAY2,ISUBGD
C INITIALIZE BDYSRC and BDYSOL
      BDYSRC=0.0
	BDYSOL=0.0
	BDYSNK=0.0
C
C  CALCULATE FLUX AND SOLUTE FLUX ACROSS SUBGRID BOUNDARIES
C
      NSROWF=0
      NSCOLF=0
      IF(ISROW1.GT.1) NSROWF=1
      IF(ISROW2.LT.NROW) NSROWF=NSROWF+1
      IF(ISCOL1.GT.1) NSCOLF=1
      IF(ISCOL2.LT.NCOL) NSCOLF=NSCOLF+1
      IDTOPM=((NSROWF*NSCOL+NSCOLF*NSROW)*NSLAY)+1
C  GET LOCATION OF EACH SUBGRID BOUNDARY FACE
      DO 100 IE=1,NFACES
         J=LOCBDY(1,IE)
         I=LOCBDY(2,IE)
         K=LOCBDY(3,IE)
         JS=J-ISCOL1+1 
         IS=I-ISROW1+1 
         KS=K-ISLAY1+1 
C 284-LESS THAN;  285-EQUAL TO;  286-GREATER THAN 0
C LESS THAN 0, CTCFLO POINTS OUT OF AQUIFER 
C GREATER THAN 0, CTCFLO POINTS INTO AQUIFER 
         IF (CTCFLO(IE)) 200,100,300
C SUBGRID BOUNDARY SINK
 200  CONTINUE
C SUM FLOWS 
         BDYSNK(JS,IS,KS)=BDYSNK(JS,IS,KS)+CTCFLO(IE)
      GOTO 100     
C SUBGRID BOUNDARY SOURCE
 300  CONTINUE
C IF NOT CYCLING THROUGH LAYER FACES
         IF (IE.LT.IDTOPM) THEN
cgzh debug! hardwire for wellbore problem #2
c           if(js.eq.1.and.is.gt.18) then
cgzh cinxy
c           CPRIME=CINFL(KS)
            CPRIME=CINXY(JS,IS,KS)
c	     else
c           cprime=0.0
c	     end if
C IF CYCLING THROUGH LAYER FACES, CHECK SUBGRID PLACEMENT
         ELSE
cgzh cbdy
            CPRIME=0.0
            IF (MOD(IE,2).EQ.0) THEN
              CPRIME=CINFLB(JS,IS)  
            ELSE
              CPRIME=CINFLA(JS,IS)  
            END IF
         END IF
C
C SUM FLOWS AND MASS FLUX
         BDYSRC(JS,IS,KS)=BDYSRC(JS,IS,KS)+CTCFLO(IE)
         BDYSOL(JS,IS,KS)=BDYSOL(JS,IS,KS)+CTCFLO(IE)*CPRIME
cgzh debug
      if(js.eq.1.and.is.eq.1.and.ks.eq.1) then
	continue
	endif
 100  CONTINUE
C
      RETURN
      END
C
C
C  ADDPTS  
C add particles at a cell, weighted option (variable pt density not being used)
C     ***************************************************************
C
      SUBROUTINE ADDPTS(PC,PR,PL,PCONC,
     *   C1,IPTID,NPCELL,
     *   IBOUND,PNEWC,PNEWR,PNEWL,
     *   PTWT,VOL,
     *   NCOL,NROW,NLAY,NSCOL,NSROW,NSLAY,
     *   NEWPTS,NPMAX,
     *   JS,IS,KS,
     *   IOUTS,NPTM,WTFAC)
C
C     ***************************************************************
C
C     GENERATE PARTICLE POSITIONS
C
C     C1: CONCENTRATION TO BE GIVEN TO NEW PARTICLES
C     VOL: VOLUME TO BE DISTRIBUTED TO ALL PARTICLES
C
cgzh debug double ptwt
      DOUBLE PRECISION PTWT,VOL,WT
      DIMENSION PC(NPMAX),PR(NPMAX),PL(NPMAX),PCONC(NPMAX),
     *   IPTID(NPMAX),WTFAC(NSCOL,NSROW,NSLAY),
     *   NPCELL(NSCOL,NSROW,NSLAY),PTWT(NPMAX),
     *   PNEWC(NEWPTS),PNEWR(NEWPTS),PNEWL(NEWPTS)
      DIMENSION IBOUND(NCOL,NROW,NLAY)
C
      COMMON /GWT/ CDEL,RDEL,CNOFLO,CELDIS,FZERO,NZCRIT
      COMMON /SUBGRD/
     *  ISCOL1,ISCOL2,ISROW1,ISROW2,ISLAY1,ISLAY2,ISUBGD
C
C     ***************************************************************
C
C  NPTPND IS NEWPTS MINUS 1
cgzh will need to make NPTPND defined for each cell
      NPTPND=NEWPTS-1
C     ***************************************************************
C     ---INSERT PARTICLES---
CMOCWT
      NPCELL(JS,IS,KS)=NPTPND
C  DISTRIBUTE WEIGHT OVER ALL PARTICLES
      WT=VOL/REAL(NPTPND)
      IND=0
C  USE NEW LOCATIONS
C  CORRECT FOR SUBGRID
      K=KS+ISLAY1-1
      I=IS+ISROW1-1
      J=JS+ISCOL1-1
cgzh debug  check IBOUND here too (see SMOC5GP)
      DO 10 IP=1,NPTPND
C START NEW IDS AFTER NPTM
      IND=IP+NPTM
      IF(IND.GT.NPMAX) THEN
         WRITE(IOUTS,*) IND
         WRITE(IOUTS,*) ' ** ERROR ** -- NPMAX EXCEEDED, STOPPING'
         WRITE(IOUTS,*) ' INCREASE NPMAX AND RERUN (SUBR: ADDPTS)'
         STOP
      END IF
      PC(IND)=J+PNEWC(IP)
      PR(IND)=-I-PNEWR(IP)
      PL(IND)=K+PNEWL(IP)
      PTWT(IND)=WT
      PCONC(IND)=C1
      IPTID(IND)=IP
cgzh debug output
c      write(iouts,*) 'New pt in explode routine'
c      write(iouts,*) 'IND,IP,PCONC,PTWT',IND,IP,PCONC(IND),PTWT(IND)
  10  CONTINUE
C
C  INCREASE TOTAL NUMBER OF PARTICLES 
      NPTM=IND
C
C     ****************************************************************
      RETURN
C     ****************************************************************
      END
C
C
C  ADDPTSVAR  
C add particles at a cell, weighted option (variable pt density being used)
C     ***************************************************************
C
      SUBROUTINE ADDPTSVAR(PC,PR,PL,PCONC,
     *   C1,NPCELL,
     *   PCORIG,PRORIG,PLORIG,
     *   PTWT,VOL,
     *   NSCOL,NSROW,NSLAY,
     *   NPMAX,NPTCOL,NPTROW,NPTLAY,
     *   JS,IS,KS,
     *   IOUTS,NPTM,IDIM,WTFAC)
C
C     ***************************************************************
C
C     GENERATE PARTICLE POSITIONS
C
C     C1: CONCENTRATION TO BE GIVEN TO NEW PARTICLES
C     VOL: VOLUME TO BE DISTRIBUTED TO ALL PARTICLES
C
cgzh debug double ptwt
      DOUBLE PRECISION PTWT,VOL,WT
	REAL LLOC,RLOC,CLOC,LSPAC,RSPAC,CSPAC
      DIMENSION PC(NPMAX),PR(NPMAX),PL(NPMAX),PCONC(NPMAX),
     *   NPCELL(NSCOL,NSROW,NSLAY),PTWT(NPMAX),WTFAC(NSCOL,NSROW,NSLAY)
cgzh varpt
      DIMENSION PCORIG(NPMAX),PRORIG(NPMAX),PLORIG(NPMAX)
C
      COMMON /SUBGRD/
     *  ISCOL1,ISCOL2,ISROW1,ISROW2,ISLAY1,ISLAY2,ISUBGD
C
C     ***************************************************************
cgzh debug add comments for this routine
c
C     ---INSERT PARTICLES---
cgzh circle
      IF(NPTLAY.GT.0) THEN
        NPTPND=NPTCOL*NPTROW*NPTLAY
      ELSE
C NEGATIVE NPTLAY FLAGS CIRCLE OF POINTS
        NPTPND=-NPTLAY
	END IF
      NPCELL(JS,IS,KS)=NPTPND
C  DISTRIBUTE WEIGHT OVER ALL PARTICLES
      WT=VOL/REAL(NPTPND)
C START NEW IDS AFTER NPTM
      IND=NPTM
C     
      IF(NPTLAY.GT.0) THEN
C  DETERMINE PARTICLE SPACING IN EACH DIRECTION
        LSPAC=1.0/REAL(NPTLAY)
        RSPAC=1.0/REAL(NPTROW)
        CSPAC=1.0/REAL(NPTCOL)
cgzh debug output
c        write(iouts,'(2A,3I3)') '        IND,  PC(IND),       PR(IND),',
c     *  '     PL(IND)     at ',js,is,ks
C  DETERMINE FIRST RELATIVE LOCATION IN EACH DIRECTION, (R+C MID LOOP)
c  set init layer loc by backing up 1/2 the spacing to get the ball rolling
c  (it only needs to be set once)
        LLOC=-0.5-LSPAC/2
        DO 10 IL=1,NPTLAY
C  INCREMENT LAYER RELATIVE LOCATION
          LLOC=LLOC+LSPAC
c  set init row loc (it is reset each loop over layers)
          RLOC=-0.5-RSPAC/2
C  INCREMENT ROW RELATIVE LOCATION
        DO 10 IR=1,NPTROW
          RLOC=RLOC+RSPAC
c  set init col loc (it is reset each loop over rows)
          CLOC=-0.5-CSPAC/2
C  INCREMENT COLUMN RELATIVE LOCATION
        DO 10 IC=1,NPTCOL
          CLOC=CLOC+CSPAC
C  GET NEXT PARTICLE INDEX
          IND=IND+1
          IF(IND.GT.NPMAX) THEN
           WRITE(IOUTS,*) IND
           WRITE(IOUTS,*) ' ** ERROR ** -- NPMAX EXCEEDED, STOPPING'
           WRITE(IOUTS,*) ' INCREASE NPMAX AND RERUN (SUBR: ADDPTSVAR1)'
           STOP
          END IF
C  PARTICLE POSITIONS DEFINED ON FLOW GRID COORDINATES
          K=KS+ISLAY1-1
          I=IS+ISROW1-1
          J=JS+ISCOL1-1
          PTWT(IND)=WT
          PCONC(IND)=C1
C  SET LOCATION = GRID CELL PLUS RELATIVE LOCATION
          PC(IND)=J+CLOC
          PCORIG(IND)=PC(IND)
          PR(IND)=-I-RLOC
          PRORIG(IND)=PR(IND)
          PL(IND)=K+LLOC
cgzh debug...leave orig position as wt-uncorrected version, as a new pt will be corrected
          PLORIG(IND)=PL(IND)
  10    CONTINUE
C
cgzh square
      ELSE
cgzh skipping square 
       go to 888
C
        NPTSSIDE=-NPTLAY
C 
cgzh square
C       FIRST DEFINE CORNERS
        SIDELENGTH=0.5
c  set init layer loc by backing up 1/2 the spacing to get the ball rolling
c  (it only needs to be set once)
c        LLOC=-0.5-LSPAC/2
c        DO 20 IL=1,NPTLAY
C  INCREMENT LAYER RELATIVE LOCATION
c          LLOC=LLOC+LSPAC
          LLOC=0.0
c  set init row loc (it is reset each loop over layers)
          RLOC=-0.5-SIDELENGTH/2
C  INCREMENT ROW RELATIVE LOCATION
        DO 20 IR=1,2
          RLOC=RLOC+SIDELENGTH
c  set init col loc (it is reset each loop over rows)
          CLOC=-0.5-SIDELENGTH/2
C  INCREMENT COLUMN RELATIVE LOCATION
        DO 20 IC=1,2
          CLOC=CLOC+SIDELENGTH
C  GET NEXT PARTICLE INDEX
          IND=IND+1
          IF(IND.GT.NPMAX) THEN
           WRITE(IOUTS,*) IND
           WRITE(IOUTS,*) ' ** ERROR ** -- NPMAX EXCEEDED, STOPPING'
           WRITE(IOUTS,*) ' INCREASE NPMAX AND RERUN (SUBR: ADDPTSVAR2)'
           STOP
          END IF
C  PARTICLE POSITIONS DEFINED ON FLOW GRID COORDINATES
          K=KS+ISLAY1-1
          I=IS+ISROW1-1
          J=JS+ISCOL1-1
          PTWT(IND)=WT
          PCONC(IND)=C1
C  SET LOCATION = GRID CELL PLUS RELATIVE LOCATION
          PC(IND)=J+CLOC
          PCORIG(IND)=PC(IND)
          PR(IND)=-I-RLOC
          PRORIG(IND)=PR(IND)
          PL(IND)=K+LLOC
          PLORIG(IND)=PL(IND)
  20    CONTINUE
C
C   NEXT CHECK TO SEE IF THERE ARE ANY MORE POINTS ON SQUARE        
        IF(NPTSSIDE.GT.2) THEN
          SPACING=SIDELENGTH/REAL(NPTSSIDE-1)
C
C  DETERMINE FIRST RELATIVE LOCATION IN EACH DIRECTION, (R+C MID LOOP)
c        LLOC=-0.5-SPACING/2
C  INCREMENT LAYER RELATIVE LOCATION
c        DO 10 IL=1,NPTSSIDE
c          LLOC=LLOC+SPACING
          LLOC=0.0
C  DO BOTTOM AND TOP SIDES FIRST
c  set init col loc (it is reset each loop over rows)
          CLOC=-0.5-SIDELENGTH/2
C  INCREMENT COLUMN RELATIVE LOCATION
        DO 30 IC=1,2
          CLOC=CLOC+SIDELENGTH
C  START AT CORNER AND MOVE IN 
          RLOC=-SIDELENGTH/2.0
C  INCREMENT ROW RELATIVE LOCATION
          DO 30 IR=1,NPTSSIDE-2
            RLOC=RLOC+SPACING
C  GET NEXT PARTICLE INDEX
            IND=IND+1
            IF(IND.GT.NPMAX) THEN
            WRITE(IOUTS,*) IND
            WRITE(IOUTS,*) ' ** ERROR ** -- NPMAX EXCEEDED, STOPPING'
            WRITE(IOUTS,*) 'INCREASE NPMAX AND RERUN (SUBR: ADDPTSVAR3)'
            STOP
            END IF
C  PARTICLE POSITIONS DEFINED ON FLOW GRID COORDINATES
            K=KS+ISLAY1-1
            I=IS+ISROW1-1
            J=JS+ISCOL1-1
            PTWT(IND)=WT
            PCONC(IND)=C1
C  SET LOCATION = GRID CELL PLUS RELATIVE LOCATION
            PC(IND)=J+CLOC
            PCORIG(IND)=PC(IND)
            PR(IND)=-I-RLOC
            PRORIG(IND)=PR(IND)
            PL(IND)=K+LLOC
            PLORIG(IND)=PL(IND)
   30 CONTINUE
C
C  DETERMINE FIRST RELATIVE LOCATION IN EACH DIRECTION, (R+C MID LOOP)
c        LLOC=-0.5-SPACING/2
C  INCREMENT LAYER RELATIVE LOCATION
c        DO 10 IL=1,NPTSSIDE
c          LLOC=LLOC+SPACING
          LLOC=0.0
C  DO LEFT AND RIGHT SIDES NOW
c  set init col loc (it is reset each loop over rows)
          RLOC=-0.5-SIDELENGTH/2
C  INCREMENT COLUMN RELATIVE LOCATION
        DO 40 IR=1,2
          RLOC=RLOC+SIDELENGTH
c  START AT CORNER AND MOVE IN 
          CLOC=-SIDELENGTH/2.0
C  INCREMENT ROW RELATIVE LOCATION
          DO 40 IC=1,NPTSSIDE-2
            CLOC=CLOC+SPACING
C  GET NEXT PARTICLE INDEX
            IND=IND+1
            IF(IND.GT.NPMAX) THEN
            WRITE(IOUTS,*) IND
            WRITE(IOUTS,*) ' ** ERROR ** -- NPMAX EXCEEDED, STOPPING'
            WRITE(IOUTS,*) 'INCREASE NPMAX AND RERUN (SUBR: ADDPTSVAR4)'
            STOP
            END IF
C  PARTICLE POSITIONS DEFINED ON FLOW GRID COORDINATES
            K=KS+ISLAY1-1
            I=IS+ISROW1-1
            J=JS+ISCOL1-1
            PTWT(IND)=WT
            PCONC(IND)=C1
C  SET LOCATION = GRID CELL PLUS RELATIVE LOCATION
            PC(IND)=J+CLOC
            PCORIG(IND)=PC(IND)
            PR(IND)=-I-RLOC
            PRORIG(IND)=PR(IND)
            PL(IND)=K+LLOC
            PLORIG(IND)=PL(IND)
   40 CONTINUE
        END IF 
cgzh square end square
C
 888  CONTINUE 
cgzh circle
          NPTS=-NPTLAY
	    PI=3.141592653589
C  SET RADIUS OF CIRCLE OF PARTICLES
cgzh debug radius should be??
C          RADIUS=0.33333333333333
C          RADIUS=0.25
          RADIUS=0.49
C  CYCLE THROUGH NPTS DEGREE DIVISIONS OF CIRCLE
        DO 50 N=1,NPTS
          ANGDEG=360.0*N/NPTS
C  CONVERT TO RADIANS FOR COS AND SIN FUNCTIONS
          ANGRAD=ANGDEG*PI/180.0
          CLOC=RADIUS*COS(ANGRAD)
          RLOC=RADIUS*SIN(ANGRAD)
          LLOC=0.0
C  GET NEXT PARTICLE INDEX
            IND=IND+1
            IF(IND.GT.NPMAX) THEN
            WRITE(IOUTS,*) IND
            WRITE(IOUTS,*) ' ** ERROR ** -- NPMAX EXCEEDED, STOPPING'
            WRITE(IOUTS,*) 'INCREASE NPMAX AND RERUN (SUBR: ADDPTSVAR5)'
            STOP
            END IF
C  PARTICLE POSITIONS DEFINED ON FLOW GRID COORDINATES
            K=KS+ISLAY1-1
            I=IS+ISROW1-1
            J=JS+ISCOL1-1
            PTWT(IND)=WT
            PCONC(IND)=C1
C  SET LOCATION = GRID CELL PLUS RELATIVE LOCATION
            PC(IND)=J+CLOC
            PCORIG(IND)=PC(IND)
            PR(IND)=-I-RLOC
            PRORIG(IND)=PR(IND)
            PL(IND)=K+LLOC
            PLORIG(IND)=PL(IND)
   50   CONTINUE
      END IF
C
C  INCREASE TOTAL NUMBER OF PARTICLES 
      NPTM=IND
C
C     ****************************************************************
      RETURN
C     ****************************************************************
      END
C
!RBW begin new subroutine
C Subroutine SMOC5SetCmaxAndCmin
C     FIND MAX & MIN CONC IN ADJACENT CELLS TO DEFINE NORMALIZED RANGE TO
C         CONSTRAIN CHANGE IN CONC. DUE TO DISPERSION
C     CHECK VS AVERAGE CONC AS WELL (THOSE ARE THE VALUES USED IN THE DISPERSION
C         CALCULATIONS)

      Subroutine SMOC5SetCmaxAndCmin(IBOUND, CONC,CAVG,CMAX,CMIN,
     *   NSCOL,NSROW,NSLAY, NCOL,NROW,NLAY,
     *   ISLAY1,ISROW1,ISCOL1,
     *   Col, Row, Layer, ColS, RowS, LayerS)
      implicit None
      integer IBOUND, NSCOL,NSROW,NSLAY, NCOL,NROW,NLAY,
     *   ISLAY1,ISROW1,ISCOL1, 
     *   Col, Row, Layer, ColS, RowS, LayerS
      integer ColMin, ColMax, ColIterator
      integer RowMin, RowMax, RowIterator
      integer LayerMin, LayerMax, LayerIterator
      integer K,I,J
      real CONC,CAVG,CMAX,CMIN
      Logical Initialized
      DIMENSION
     *  IBOUND(NCOL,NROW,NLAY),
     *  CONC(NSCOL,NSROW,NSLAY),CAVG(NSCOL,NSROW,NSLAY),
     *  CMAX(NSCOL,NSROW,NSLAY),CMIN(NSCOL,NSROW,NSLAY)

      if (ColS.gt.1) then
        ColMin = ColS-1
      else
        ColMin = 1
      endif
      if (RowS.gt.1) then
        RowMin = RowS-1
      else
        RowMin = 1
      endif
      if (LayerS.gt.1) then
        LayerMin = LayerS-1
      else
        LayerMin = 1
      endif

      if (ColS.lt.NSCOL) then
        ColMax = ColS+1
      else
        ColMax = NSCOL
      endif
      if (RowS.lt.NSROW) then
        RowMax = RowS+1
      else
        RowMax = NSROW
      endif
      if (LayerS.lt.NSLAY) then
        LayerMax = LayerS+1
      else
        LayerMax = NSLAY
      endif

      Initialized = .False.
      do LayerIterator = LayerMin, LayerMax
        K=LayerIterator+ISLAY1-1
        do RowIterator = RowMin, RowMax
          I=RowIterator+ISROW1-1
          do ColIterator = ColMin, ColMax
            J=ColIterator+ISCOL1-1
            if ((LayerIterator.ne.LayerS).or.(RowIterator.ne.RowS)
     *         .or.(ColIterator.ne.ColS)) then
              IF(IBOUND(J,I,K).NE.0) THEN 
                if (Initialized) then
                  IF (CONC(ColIterator,RowIterator,LayerIterator)
     *                 .GT.CMAX(ColS,RowS,LayerS))
     *              CMAX(ColS,RowS,LayerS)=
     *                CONC(ColIterator,RowIterator,LayerIterator)
	            IF (CONC(ColIterator,RowIterator,LayerIterator)
     *                 .LT.CMIN(ColS,RowS,LayerS)) 
     *              CMIN(ColS,RowS,LayerS)=
     *                CONC(ColIterator,RowIterator,LayerIterator)
                else
                  Initialized = .TRUE.
                  CMAX(ColS,RowS,LayerS)=
     *              CONC(ColIterator,RowIterator,LayerIterator)
                  CMIN(ColS,RowS,LayerS)=
     *              CONC(ColIterator,RowIterator,LayerIterator)
                endif
	          IF (CAVG(ColIterator,RowIterator,LayerIterator)
     *               .GT.CMAX(ColS,RowS,LayerS))
     *            CMAX(ColS,RowS,LayerS)=
     *              CAVG(ColIterator,RowIterator,LayerIterator)
	          IF (CAVG(ColIterator,RowIterator,LayerIterator)
     *               .LT.CMIN(ColS,RowS,LayerS)) 
     *            CMIN(ColS,RowS,LayerS)=
     *               CAVG(ColIterator,RowIterator,LayerIterator)
              endif
            endif
          enddo
        enddo
      enddo
      if (.not.Initialized) then
         CMAX(ColS,RowS,LayerS)=CONC(ColS,RowS,LayerS)
         CMIN(ColS,RowS,LayerS)=CONC(ColS,RowS,LayerS)
	   IF (CAVG(ColS,RowS,LayerS).GT.CMAX(ColS,RowS,LayerS))
     *     CMAX(ColS,RowS,LayerS)=CAVG(ColS,RowS,LayerS)
	   IF (CAVG(ColS,RowS,LayerS).LT.CMIN(ColS,RowS,LayerS)) 
     *     CMIN(ColS,RowS,LayerS)=CAVG(ColS,RowS,LayerS)
      endif
      return
      end;
!RBW end new subroutine    
C
C  MOC5WTAP  CHANGE CONC OF NODES AND PARTICLES
C*************************************************************************
C
      SUBROUTINE MOC5WTAP(IBOUND,
     *  PC,PR,PL,PCONC,
cgzh debug  iimov
     *  SBVL,SUMWT,PTWT,CELVOL,iimov,
     *  CONC,CAVG,
     *  SUMMASS,CNCNC,
     *  NSCOL,NSROW,NSLAY,NPMAX,
     *  NCOL,NROW,NLAY,IOUTS,NP,NIUNIT,
cgzh ccbd
     *  INCCBD,CCBDY)
C
C*************************************************************************
C
C  CHANGE CONC OF NODES AND PARTICLES DUE TO DISPERSION AND SINK/SOURCES
C
C TEMPORARY ARRAYS
cgzh debug double ptwt, sumwt
      DOUBLE PRECISION CELVOL
      DOUBLE PRECISION PTWT,SUMWT
cgzh debug double sbvl
      DOUBLE PRECISION SBVL
cgzh debug double sumvol
      DOUBLE PRECISION SUMVOL,CUMMASS,SUMMASS,CUMMASS2
cgzh ccbd
      DOUBLE PRECISION TOTIN,TOTOUT,DIFFMASS,CHNGMASS
cgzh debug
      INTEGER PTFLAG
      ALLOCATABLE CNMASS(:,:,:),CNCPCT(:,:,:)
      ALLOCATABLE CMIN(:,:,:),CMAX(:,:,:),CX(:,:,:)
cgzh debug
      ALLOCATABLE SUMPTWT(:,:,:)
cgzh debug
      ALLOCATABLE PTFLAG(:,:,:)
cgzh debug
      ALLOCATABLE cummass2(:,:,:)
cgzh ccbd
      ALLOCATABLE CHNGMASS(:,:,:)
      DIMENSION
     *  IBOUND(NCOL,NROW,NLAY),
     *  PC(NPMAX),PR(NPMAX),PL(NPMAX),PCONC(NPMAX),
     *  CONC(NSCOL,NSROW,NSLAY),CAVG(NSCOL,NSROW,NSLAY),
     *  SUMMASS(NSCOL,NSROW,NSLAY), CNCNC(NSCOL,NSROW,NSLAY)
      DIMENSION  
     *  SUMWT(NSCOL,NSROW,NSLAY),PTWT(NPMAX),
     *  SBVL(6,NIUNIT),CELVOL(NSCOL,NSROW,NSLAY)
cgzh ccbd
      DIMENSION CCBDY(NSCOL,NSROW,NSLAY)               
C
      COMMON /SUBGRD/
     *  ISCOL1,ISCOL2,ISROW1,ISROW2,ISLAY1,ISLAY2,ISUBGD
C
C*************************************************************************
C
      ALLOCATE(CNMASS(NSCOL,NSROW,NSLAY),CNCPCT(NSCOL,NSROW,NSLAY))
      ALLOCATE(CMAX(NSCOL,NSROW,NSLAY),CMIN(NSCOL,NSROW,NSLAY))
      ALLOCATE(CX(NSCOL,NSROW,NSLAY))
cgzh debug
      ALLOCATE(cummass2(NSCOL,NSROW,NSLAY))
cgzh debug
      ALLOCATE(SUMPTWT(NSCOL,NSROW,NSLAY))
cgzh debug
      ALLOCATE(PTFLAG(NSCOL,NSROW,NSLAY))
cgzh ccbd
      ALLOCATE(CHNGMASS(NSCOL,NSROW,NSLAY))
C  INITIALIZE MASS BALANCE COUNTERS
cgzh debug output roland
c      if(iimov.eq.27) then 
c	  write(*,*) 'A: wtap pconc(761)',pconc(761)
c	end if
cgzh debug output roland
      SUMVOL=0.0
      CUMMASS=0.0
cgzh debug
      SUMPTWT=0.0
C  LOOP OVER CELLS TO APPLY CHANGE IN CONCENTRATION TO NODES
C    AND COMPUTE CHANGE IN CONCENTRATION TO BE APPLIED TO PARTICLES
cgzh debug
       icll=0
cgzh debug
      cmsinc=0.0
	cmsdec=0.0
      cinc=0.0
	cdec=0.0
      sumcnm=0.0
      sumcnc=0.0
      DO 65 KS=1,NSLAY
      K=KS+ISLAY1-1
      DO 65 IS=1,NSROW
      I=IS+ISROW1-1
      DO 65 JS=1,NSCOL
      J=JS+ISCOL1-1
      IF(IBOUND(J,I,K).EQ.0) GO TO 65
cgzh debug
c      if(iimov.eq.57.and.js.eq.24.and.is.eq.21) then
c	continue
c	end if
cgzh debug  SUM WEIGHTS AND MASS BEFORE DISPERSION APPLIED
cgzh debug    should match the sum after dispersion
      SUMVOL=SUMVOL+SUMWT(JS,IS,KS)
      CUMMASS=CUMMASS+SUMMASS(JS,IS,KS)
c
C  CNCPCT IS PERCENT CHANGE IN CONCENTRATION OF NODE
C   USE CNCPCT TO CHANGE PARTICLE CONCENTRATIONS IF CONC DROPPING
C
      CNCPCT(JS,IS,KS)=0.0
	CX(JS,IS,KS)=0.0
cgzh ccbd
      IF(INCCBD.GT.0) CHNGMASS=0.D0     
cgzh debug output
c      if(js.eq.23.and.is.eq.5.and.iimov.ge.30) then
c      if(summass(js,is,ks).gt.0.0) then
c          write(iouts,*) 'A: js,is,ks,sumwt,summass', 
c     * js,is,ks,sumwt(js,is,ks),summass(js,is,ks)
c      write(iouts,*) 'wtap:  cncnc before update',
c     * CNCNC(JS,IS,KS)
c      write(iouts,*) 'wtap:  conc before ',
c     * CONC(JS,IS,KS)
c	  end if   
c	  end if   
c       if(summass(js,is,ks).gt.0.0) then
c	   icll=icll+1
c         write(iouts,*) 'MB summass=     ',
c     * summass(js,is,ks)
c       end if
cgzh debug output
c       if(js.eq.2.and.is.eq.1) then
c	   if(cncnc(js,is,ks).ne.0.0) then
c      if(js.eq.4.and.is.eq.1) then
c      if(js.eq.138.and.ks.eq.2.and.iimov.gt.2670) then
c      if(js.eq.140.and.ks.eq.2) then
c	   if(cncnc(js,is,ks).ne.0.0) then
c      write(iouts,*) 'wtap:  cncnc before update',
c     * CNCNC(JS,IS,KS)
c      write(iouts,*) 'wtap:  summass, sumwt, summass/sumwt',
c     * SUMMASS(JS,IS,KS),SUMWT(JS,IS,KS),
c     * (SUMMASS(JS,IS,KS)/SUMWT(JS,IS,KS))
c      write(iouts,*) 'wtap:  conc before 2,1',
c     * CONC(JS,IS,KS)
c       endif
c       endif
C     ****************************************************************
C     ---CHANGE CONCENTRATION AT NODE---
cgzh debug
c this is unneeded with this version (src term already handled), so 
c instead recompute conc pased on new pt concs below
c   will this work with DP, AGE, etc?
c      CONC(JS,IS,KS)=CONC(JS,IS,KS)+CNCNC(JS,IS,KS)
C
C Initialize PTFLAG (used to determine course of action in PT update loop below)
      PTFLAG(JS,IS,KS)=0
C  CHANGE IN MASS DUE TO DISP IS CHANGE IN CONC * CELVOL
      IF (CNCNC(JS,IS,KS).EQ.0.0) THEN
         CNMASS(JS,IS,KS)=0.0
	   GO TO 65
	ELSE
         CNMASS(JS,IS,KS)=CNCNC(JS,IS,KS)*CELVOL(JS,IS,KS)
cgzh debug
c         sumcnc=sumcnc+CNCNC(JS,IS,KS)
c         sumcnm=sumcnm+CNMASS(JS,IS,KS)
c       write(iouts,*) 'cnmass,cncnc, js, ks',
c     * cnmass(js,is,ks),cncnc(js,is,ks),js,ks
       if (cnmass(js,is,ks).gt.0.00) then
	   cmsinc=cmsinc+cnmass(js,is,ks)
c         write(iouts,*) 'inc at js,is,ks of:',js,is,ks,cnmass(js,is,ks)
	 end if
       if (cnmass(js,is,ks).lt.0.00) then
	   cmsdec=cmsdec+cnmass(js,is,ks)
c         write(iouts,*) 'dec at js,is,ks of:',js,is,ks,cnmass(js,is,ks)
	 end if
      END IF
C  SET CHANGE IN CONC RELATIVE TO WEIGHTS ON PARTICLES (CONSERVES MASS)
C    IF CELVOL VERY DIFFERENT THAN SUMWT, THIS MAY CAUSE WEIRD PCONCS
      IF (SUMWT(JS,IS,KS).GT.0.0) THEN
        CNCNC(JS,IS,KS)=CNMASS(JS,IS,KS)/SUMWT(JS,IS,KS)
	END IF
C
coldest     IF(CONC(JS,IS,KS).GT.0.0) CNCPCT=CNCNC(JS,IS,KS)/CONC(JS,IS,KS)
cold      IF(CONC(JS,IS,KS).GT.0.0.AND.CNCNC(JS,IS,KS).LT.0.0) 
cold     *   CNCPCT=CNCNC(JS,IS,KS)/CONC(JS,IS,KS)
C
C  PERCENT CHANGE IN CONC EQUAL TO RATIO OF CHANGE IN MASS, NOT CONC LIKE IN OLD
C  STORE PERCENT CHANGE TO USE FOR PARTICLES
cgzh debug   cncpct is never positive
C      IF(SUMMASS(JS,IS,KS).GT.0.0.AND.CNMASS(JS,IS,KS).LT.0.0) 
C     *   CNCPCT(JS,IS,KS)=CNMASS(JS,IS,KS)/SUMMASS(JS,IS,KS)
C
C  END OF LOOP FOR CHANGES IN NODE CONCENTRATIONS
C
C     FIND MAX & MIN CONC IN ADJACENT CELLS TO DEFINE NORMALIZED RANGE TO
C         CONSTRAIN CHANGE IN CONC. DUE TO DISPERSION
C     CHECK VS AVERAGE CONC AS WELL (THOSE ARE THE VALUES USED IN THE DISPERSION
C         CALCULATIONS)
      Call SMOC5SetCmaxAndCmin(IBOUND, CONC,CAVG,CMAX,CMIN,
     *   NSCOL,NSROW,NSLAY, NCOL,NROW,NLAY,
     *   ISLAY1,ISROW1,ISCOL1,
     *   J,I,K, JS,IS,KS)
!      CMAX(JS,IS,KS)=CONC(JS,IS,KS)
!	CMIN(JS,IS,KS)=CONC(JS,IS,KS)
C       FORWARD COL. DIRECTION
!      IF (JS.LT.NSCOL) THEN
!	  IF(IBOUND(J+1,I,K).NE.0) THEN
!	   IF (CONC(JS+1,IS,KS).GT.CMAX(JS,IS,KS))
!     *              CMAX(JS,IS,KS)=CONC(JS+1,IS,KS)
!	   IF (CAVG(JS+1,IS,KS).GT.CMAX(JS,IS,KS))
!     *              CMAX(JS,IS,KS)=CAVG(JS+1,IS,KS)
!	   IF (CONC(JS+1,IS,KS).LT.CMIN(JS,IS,KS)) 
!     *              CMIN(JS,IS,KS)=CONC(JS+1,IS,KS)
!	   IF (CAVG(JS+1,IS,KS).LT.CMIN(JS,IS,KS)) 
!     *              CMIN(JS,IS,KS)=CAVG(JS+1,IS,KS)
!        END IF
C          CROSS-PRODUCT TERMS
C             LAYER K
!          IF (IS.LT.NSROW) THEN
!		 IF(IBOUND(J+1,I+1,K).NE.0) THEN
!	      IF (CONC(JS+1,IS+1,KS).GT.CMAX(JS,IS,KS))
!     *              CMAX(JS,IS,KS)=CONC(JS+1,IS+1,KS)
!	      IF (CAVG(JS+1,IS+1,KS).GT.CMAX(JS,IS,KS))
!     *              CMAX(JS,IS,KS)=CAVG(JS+1,IS+1,KS)
!	      IF (CONC(JS+1,IS+1,KS).LT.CMIN(JS,IS,KS)) 
!     *              CMIN(JS,IS,KS)=CONC(JS+1,IS+1,KS)
!	      IF (CAVG(JS+1,IS+1,KS).LT.CMIN(JS,IS,KS)) 
!     *              CMIN(JS,IS,KS)=CAVG(JS+1,IS+1,KS)
!           END IF
!          END IF
!          IF (IS.GT.1) THEN
!		 IF(IBOUND(J+1,I-1,K).NE.0) THEN
!	      IF (CONC(JS+1,IS-1,KS).GT.CMAX(JS,IS,KS))
!     *              CMAX(JS,IS,KS)=CONC(JS+1,IS-1,KS)
!	      IF (CAVG(JS+1,IS-1,KS).GT.CMAX(JS,IS,KS))
!     *              CMAX(JS,IS,KS)=CAVG(JS+1,IS-1,KS)
!	      IF (CONC(JS+1,IS-1,KS).LT.CMIN(JS,IS,KS)) 
!     *              CMIN(JS,IS,KS)=CONC(JS+1,IS-1,KS)
!	      IF (CAVG(JS+1,IS-1,KS).LT.CMIN(JS,IS,KS)) 
!     *              CMIN(JS,IS,KS)=CAVG(JS+1,IS-1,KS)
!           END IF
!          END IF
!      END IF
C       BACKWARD COL. DIRECTION
!      IF (JS.GT.1) THEN
!	  IF(IBOUND(J-1,I,K).NE.0) THEN
!	   IF (CONC(JS-1,IS,KS).GT.CMAX(JS,IS,KS))
!     *              CMAX(JS,IS,KS)=CONC(JS-1,IS,KS)
!	   IF (CAVG(JS-1,IS,KS).GT.CMAX(JS,IS,KS))
!     *              CMAX(JS,IS,KS)=CAVG(JS-1,IS,KS)
!	   IF (CONC(JS-1,IS,KS).LT.CMIN(JS,IS,KS)) 
!     *              CMIN(JS,IS,KS)=CONC(JS-1,IS,KS)
!	   IF (CAVG(JS-1,IS,KS).LT.CMIN(JS,IS,KS)) 
!     *              CMIN(JS,IS,KS)=CAVG(JS-1,IS,KS)
!        END IF
C          CROSS-PRODUCT TERMS
C             LAYER K
!          IF (IS.LT.NSROW) THEN
!		 IF(IBOUND(J-1,I+1,K).NE.0) THEN
!	      IF (CONC(JS-1,IS+1,KS).GT.CMAX(JS,IS,KS))
!     *              CMAX(JS,IS,KS)=CONC(JS-1,IS+1,KS)
!	      IF (CAVG(JS-1,IS+1,KS).GT.CMAX(JS,IS,KS))
!     *              CMAX(JS,IS,KS)=CAVG(JS-1,IS+1,KS)
!	      IF (CONC(JS-1,IS+1,KS).LT.CMIN(JS,IS,KS)) 
!     *              CMIN(JS,IS,KS)=CONC(JS-1,IS+1,KS)
!	      IF (CAVG(JS-1,IS+1,KS).LT.CMIN(JS,IS,KS)) 
!     *              CMIN(JS,IS,KS)=CAVG(JS-1,IS+1,KS)
!           END IF
!          END IF
!          IF (IS.GT.1) THEN
!		 IF(IBOUND(J-1,I-1,K).NE.0) THEN
!	      IF (CONC(JS-1,IS-1,KS).GT.CMAX(JS,IS,KS))
!     *              CMAX(JS,IS,KS)=CONC(JS-1,IS-1,KS)
!	      IF (CAVG(JS-1,IS-1,KS).GT.CMAX(JS,IS,KS))
!     *              CMAX(JS,IS,KS)=CAVG(JS-1,IS-1,KS)
!	      IF (CONC(JS-1,IS-1,KS).LT.CMIN(JS,IS,KS)) 
!     *              CMIN(JS,IS,KS)=CONC(JS-1,IS-1,KS)
!	      IF (CAVG(JS-1,IS-1,KS).LT.CMIN(JS,IS,KS)) 
!     *              CMIN(JS,IS,KS)=CAVG(JS-1,IS-1,KS)
!           END IF
!          END IF
!      END IF
C       FORWARD ROW DIRECTION
!      IF (IS.LT.NSROW) THEN
!	  IF(IBOUND(J,I+1,K).NE.0) THEN
!	   IF (CONC(JS,IS+1,KS).GT.CMAX(JS,IS,KS))
!     *              CMAX(JS,IS,KS)=CONC(JS,IS+1,KS)
!	   IF (CAVG(JS,IS+1,KS).GT.CMAX(JS,IS,KS))
!     *              CMAX(JS,IS,KS)=CAVG(JS,IS+1,KS)
!	   IF (CONC(JS,IS+1,KS).LT.CMIN(JS,IS,KS)) 
!     *              CMIN(JS,IS,KS)=CONC(JS,IS+1,KS)
!	   IF (CAVG(JS,IS+1,KS).LT.CMIN(JS,IS,KS)) 
!     *              CMIN(JS,IS,KS)=CAVG(JS,IS+1,KS)
!        END IF
!      END IF
C       BACKWARD ROW DIRECTION
!      IF (IS.GT.1) THEN
!	  IF(IBOUND(J,I-1,K).NE.0) THEN
!	   IF (CONC(JS,IS-1,KS).GT.CMAX(JS,IS,KS))
!     *              CMAX(JS,IS,KS)=CONC(JS,IS-1,KS)
!	   IF (CAVG(JS,IS-1,KS).GT.CMAX(JS,IS,KS))
!     *              CMAX(JS,IS,KS)=CAVG(JS,IS-1,KS)
!	   IF (CONC(JS,IS-1,KS).LT.CMIN(JS,IS,KS)) 
!     *              CMIN(JS,IS,KS)=CONC(JS,IS-1,KS)
!	   IF (CAVG(JS,IS-1,KS).LT.CMIN(JS,IS,KS)) 
!     *              CMIN(JS,IS,KS)=CAVG(JS,IS-1,KS)
!        END IF
!      END IF
C       FORWARD LAYER DIRECTION
!      IF (KS.LT.NSLAY) THEN
!        IF (IBOUND(J,I,K+1).NE.0) THEN
!	     IF (CONC(JS,IS,KS+1).GT.CMAX(JS,IS,KS))
!     *                CMAX(JS,IS,KS)=CONC(JS,IS,KS+1)
!	     IF (CAVG(JS,IS,KS+1).GT.CMAX(JS,IS,KS))
!     *                CMAX(JS,IS,KS)=CAVG(JS,IS,KS+1)
!	     IF (CONC(JS,IS,KS+1).LT.CMIN(JS,IS,KS)) 
!     *                CMIN(JS,IS,KS)=CONC(JS,IS,KS+1)
!	     IF (CAVG(JS,IS,KS+1).LT.CMIN(JS,IS,KS)) 
!     *                CMIN(JS,IS,KS)=CAVG(JS,IS,KS+1)
!        END IF
C          CROSS-PRODUCT TERMS
C             LAYER K+1, COL J+1
!        IF (JS.LT.NSCOL) THEN
!          IF (IBOUND(J+1,I,K+1).NE.0) THEN
!	      IF (CONC(JS+1,IS,KS+1).GT.CMAX(JS,IS,KS))
!     *              CMAX(JS,IS,KS)=CONC(JS+1,IS,KS+1)
!	      IF (CAVG(JS+1,IS,KS+1).GT.CMAX(JS,IS,KS))
!     *              CMAX(JS,IS,KS)=CAVG(JS+1,IS,KS+1)
!	      IF (CONC(JS+1,IS,KS+1).LT.CMIN(JS,IS,KS)) 
!     *              CMIN(JS,IS,KS)=CONC(JS+1,IS,KS+1)
!	      IF (CAVG(JS+1,IS,KS+1).LT.CMIN(JS,IS,KS)) 
!     *              CMIN(JS,IS,KS)=CAVG(JS+1,IS,KS+1)
!          END IF
!          IF (IS.LT.NSROW) THEN
!		 IF(IBOUND(J+1,I+1,K+1).NE.0) THEN
!	      IF (CONC(JS+1,IS+1,KS+1).GT.CMAX(JS,IS,KS))
!     *              CMAX(JS,IS,KS)=CONC(JS+1,IS+1,KS+1)
!	      IF (CAVG(JS+1,IS+1,KS+1).GT.CMAX(JS,IS,KS))
!     *              CMAX(JS,IS,KS)=CAVG(JS+1,IS+1,KS+1)
!	      IF (CONC(JS+1,IS+1,KS+1).LT.CMIN(JS,IS,KS)) 
!     *              CMIN(JS,IS,KS)=CONC(JS+1,IS+1,KS+1)
!	      IF (CAVG(JS+1,IS+1,KS+1).LT.CMIN(JS,IS,KS)) 
!     *              CMIN(JS,IS,KS)=CAVG(JS+1,IS+1,KS+1)
!           END IF
!          END IF
!          IF (IS.GT.1) THEN
!		 IF(IBOUND(J+1,I-1,K+1).NE.0) THEN
!	      IF (CONC(JS+1,IS-1,KS+1).GT.CMAX(JS,IS,KS))
!     *              CMAX(JS,IS,KS)=CONC(JS+1,IS-1,KS+1)
!	      IF (CAVG(JS+1,IS-1,KS+1).GT.CMAX(JS,IS,KS))
!     *              CMAX(JS,IS,KS)=CAVG(JS+1,IS-1,KS+1)
!	      IF (CONC(JS+1,IS-1,KS+1).LT.CMIN(JS,IS,KS)) 
!     *              CMIN(JS,IS,KS)=CONC(JS+1,IS-1,KS+1)
!	      IF (CAVG(JS+1,IS-1,KS+1).LT.CMIN(JS,IS,KS)) 
!     *              CMIN(JS,IS,KS)=CAVG(JS+1,IS-1,KS+1)
!           END IF
!          END IF
!        END IF
C             LAYER K+1, COL J-1
!        IF (JS.GT.1) THEN
!          IF (IBOUND(J-1,I,K+1).NE.0) THEN
!	      IF (CONC(JS-1,IS,KS+1).GT.CMAX(JS,IS,KS))
!     *              CMAX(JS,IS,KS)=CONC(JS-1,IS,KS+1)
!	      IF (CAVG(JS-1,IS,KS+1).GT.CMAX(JS,IS,KS))
!     *              CMAX(JS,IS,KS)=CAVG(JS-1,IS,KS+1)
!	      IF (CONC(JS-1,IS,KS+1).LT.CMIN(JS,IS,KS)) 
!     *              CMIN(JS,IS,KS)=CONC(JS-1,IS,KS+1)
!	      IF (CAVG(JS-1,IS,KS+1).LT.CMIN(JS,IS,KS)) 
!     *              CMIN(JS,IS,KS)=CAVG(JS-1,IS,KS+1)
!          END IF
!          IF (IS.LT.NSROW) THEN
!		 IF(IBOUND(J-1,I+1,K+1).NE.0) THEN
!	      IF (CONC(JS-1,IS+1,KS+1).GT.CMAX(JS,IS,KS))
!     *              CMAX(JS,IS,KS)=CONC(JS-1,IS+1,KS+1)
!	      IF (CAVG(JS-1,IS+1,KS+1).GT.CMAX(JS,IS,KS))
!     *              CMAX(JS,IS,KS)=CAVG(JS-1,IS+1,KS+1)
!	      IF (CONC(JS-1,IS+1,KS+1).LT.CMIN(JS,IS,KS)) 
!     *              CMIN(JS,IS,KS)=CONC(JS-1,IS+1,KS+1)
!	      IF (CAVG(JS-1,IS+1,KS+1).LT.CMIN(JS,IS,KS)) 
!     *              CMIN(JS,IS,KS)=CAVG(JS-1,IS+1,KS+1)
!           END IF
!          END IF
!          IF (IS.GT.1) THEN
!		 IF(IBOUND(J-1,I-1,K+1).NE.0) THEN
!	      IF (CONC(JS-1,IS-1,KS+1).GT.CMAX(JS,IS,KS))
!     *              CMAX(JS,IS,KS)=CONC(JS-1,IS-1,KS+1)
!	      IF (CAVG(JS-1,IS-1,KS+1).GT.CMAX(JS,IS,KS))
!     *              CMAX(JS,IS,KS)=CAVG(JS-1,IS-1,KS+1)
!	      IF (CONC(JS-1,IS-1,KS+1).LT.CMIN(JS,IS,KS)) 
!     *              CMIN(JS,IS,KS)=CONC(JS-1,IS-1,KS+1)
!	      IF (CAVG(JS-1,IS-1,KS+1).LT.CMIN(JS,IS,KS)) 
!     *              CMIN(JS,IS,KS)=CAVG(JS-1,IS-1,KS+1)
!           END IF
!          END IF
!        END IF
C             LAYER K+1, COL J
!          IF (IS.LT.NSROW) THEN
!		 IF(IBOUND(J,I+1,K+1).NE.0) THEN
!	      IF (CONC(JS,IS+1,KS+1).GT.CMAX(JS,IS,KS))
!     *              CMAX(JS,IS,KS)=CONC(JS,IS+1,KS+1)
!	      IF (CAVG(JS,IS+1,KS+1).GT.CMAX(JS,IS,KS))
!     *              CMAX(JS,IS,KS)=CAVG(JS,IS+1,KS+1)
!	      IF (CONC(JS,IS+1,KS+1).LT.CMIN(JS,IS,KS)) 
!     *              CMIN(JS,IS,KS)=CONC(JS,IS+1,KS+1)
!	      IF (CAVG(JS,IS+1,KS+1).LT.CMIN(JS,IS,KS)) 
!     *              CMIN(JS,IS,KS)=CAVG(JS,IS+1,KS+1)
!           END IF
!          END IF
!          IF (IS.GT.1) THEN
!		 IF(IBOUND(J,I-1,K+1).NE.0) THEN
!	      IF (CONC(JS,IS-1,KS+1).GT.CMAX(JS,IS,KS))
!     *              CMAX(JS,IS,KS)=CONC(JS,IS-1,KS+1)
!	      IF (CAVG(JS,IS-1,KS+1).GT.CMAX(JS,IS,KS))
!     *              CMAX(JS,IS,KS)=CAVG(JS,IS-1,KS+1)
!	      IF (CONC(JS,IS-1,KS+1).LT.CMIN(JS,IS,KS)) 
!     *              CMIN(JS,IS,KS)=CONC(JS,IS-1,KS+1)
!	      IF (CAVG(JS,IS-1,KS+1).LT.CMIN(JS,IS,KS)) 
!     *              CMIN(JS,IS,KS)=CAVG(JS,IS-1,KS+1)
!           END IF
!          END IF
!      END IF
C       BACKWARD LAYER DIRECTION
!      IF (KS.GT.1) THEN
!        IF (IBOUND(J,I,K-1).NE.0) THEN
!	    IF (CONC(JS,IS,KS-1).GT.CMAX(JS,IS,KS))
!     *               CMAX(JS,IS,KS)=CONC(JS,IS,KS-1)
!	    IF (CAVG(JS,IS,KS-1).GT.CMAX(JS,IS,KS))
!     *               CMAX(JS,IS,KS)=CAVG(JS,IS,KS-1)
!	    IF (CONC(JS,IS,KS-1).LT.CMIN(JS,IS,KS)) 
!     *               CMIN(JS,IS,KS)=CONC(JS,IS,KS-1)
!	    IF (CAVG(JS,IS,KS-1).LT.CMIN(JS,IS,KS)) 
!     *               CMIN(JS,IS,KS)=CAVG(JS,IS,KS-1)
!        END IF
C          CROSS-PRODUCT TERMS
C             LAYER K-1, COL J+1
!        IF (JS.LT.NSCOL) THEN
!          IF (IBOUND(J+1,I,K-1).NE.0) THEN
!	      IF (CONC(JS+1,IS,KS-1).GT.CMAX(JS,IS,KS))
!     *              CMAX(JS,IS,KS)=CONC(JS+1,IS,KS-1)
!	      IF (CAVG(JS+1,IS,KS-1).GT.CMAX(JS,IS,KS))
!     *              CMAX(JS,IS,KS)=CAVG(JS+1,IS,KS-1)
!	      IF (CONC(JS+1,IS,KS-1).LT.CMIN(JS,IS,KS)) 
!     *              CMIN(JS,IS,KS)=CONC(JS+1,IS,KS-1)
!	      IF (CAVG(JS+1,IS,KS-1).LT.CMIN(JS,IS,KS)) 
!     *              CMIN(JS,IS,KS)=CAVG(JS+1,IS,KS-1)
!          END IF
!          IF (IS.LT.NSROW) THEN
!		 IF(IBOUND(J+1,I+1,K-1).NE.0) THEN
!	      IF (CONC(JS+1,IS+1,KS-1).GT.CMAX(JS,IS,KS))
!     *              CMAX(JS,IS,KS)=CONC(JS+1,IS+1,KS-1)
!	      IF (CAVG(JS+1,IS+1,KS-1).GT.CMAX(JS,IS,KS))
!     *              CMAX(JS,IS,KS)=CAVG(JS+1,IS+1,KS-1)
!	      IF (CONC(JS+1,IS+1,KS-1).LT.CMIN(JS,IS,KS)) 
!     *              CMIN(JS,IS,KS)=CONC(JS+1,IS+1,KS-1)
!	      IF (CAVG(JS+1,IS+1,KS-1).LT.CMIN(JS,IS,KS)) 
!     *              CMIN(JS,IS,KS)=CAVG(JS+1,IS+1,KS-1)
!           END IF
!          END IF
!          IF (IS.GT.1) THEN
!		 IF(IBOUND(J+1,I-1,K-1).NE.0) THEN
!	      IF (CONC(JS+1,IS-1,KS-1).GT.CMAX(JS,IS,KS))
!     *              CMAX(JS,IS,KS)=CONC(JS+1,IS-1,KS-1)
!	      IF (CAVG(JS+1,IS-1,KS-1).GT.CMAX(JS,IS,KS))
!     *              CMAX(JS,IS,KS)=CAVG(JS+1,IS-1,KS-1)
!	      IF (CONC(JS+1,IS-1,KS-1).LT.CMIN(JS,IS,KS)) 
!     *              CMIN(JS,IS,KS)=CONC(JS+1,IS-1,KS-1)
!	      IF (CAVG(JS+1,IS-1,KS-1).LT.CMIN(JS,IS,KS)) 
!     *              CMIN(JS,IS,KS)=CAVG(JS+1,IS-1,KS-1)
!           END IF
!          END IF
!        END IF
C             LAYER K-1, COL J-1
!        IF (JS.GT.1) THEN
!          IF (IBOUND(J-1,I,K-1).NE.0) THEN
!	      IF (CONC(JS-1,IS,KS-1).GT.CMAX(JS,IS,KS))
!     *              CMAX(JS,IS,KS)=CONC(JS-1,IS,KS-1)
!	      IF (CAVG(JS-1,IS,KS-1).GT.CMAX(JS,IS,KS))
!     *              CMAX(JS,IS,KS)=CAVG(JS-1,IS,KS-1)
!	      IF (CONC(JS-1,IS,KS-1).LT.CMIN(JS,IS,KS)) 
!     *              CMIN(JS,IS,KS)=CONC(JS-1,IS,KS-1)
!	      IF (CAVG(JS-1,IS,KS-1).LT.CMIN(JS,IS,KS)) 
!     *              CMIN(JS,IS,KS)=CAVG(JS-1,IS,KS-1)
!          END IF
!          IF (IS.LT.NSROW) THEN
!		 IF(IBOUND(J-1,I+1,K-1).NE.0) THEN
!	      IF (CONC(JS-1,IS+1,KS-1).GT.CMAX(JS,IS,KS))
!     *              CMAX(JS,IS,KS)=CONC(JS-1,IS+1,KS-1)
!	      IF (CAVG(JS-1,IS+1,KS-1).GT.CMAX(JS,IS,KS))
!     *              CMAX(JS,IS,KS)=CAVG(JS-1,IS+1,KS-1)
!	      IF (CONC(JS-1,IS+1,KS-1).LT.CMIN(JS,IS,KS)) 
!     *              CMIN(JS,IS,KS)=CONC(JS-1,IS+1,KS-1)
!	      IF (CAVG(JS-1,IS+1,KS-1).LT.CMIN(JS,IS,KS)) 
!     *              CMIN(JS,IS,KS)=CAVG(JS-1,IS+1,KS-1)
!           END IF
!          END IF
!          IF (IS.GT.1) THEN
!		 IF(IBOUND(J-1,I-1,K-1).NE.0) THEN
!	      IF (CONC(JS-1,IS-1,KS-1).GT.CMAX(JS,IS,KS))
!     *              CMAX(JS,IS,KS)=CONC(JS-1,IS-1,KS-1)
!	      IF (CAVG(JS-1,IS-1,KS-1).GT.CMAX(JS,IS,KS))
!     *              CMAX(JS,IS,KS)=CAVG(JS-1,IS-1,KS-1)
!	      IF (CONC(JS-1,IS-1,KS-1).LT.CMIN(JS,IS,KS)) 
!     *              CMIN(JS,IS,KS)=CONC(JS-1,IS-1,KS-1)
!	      IF (CAVG(JS-1,IS-1,KS-1).LT.CMIN(JS,IS,KS)) 
!     *              CMIN(JS,IS,KS)=CAVG(JS-1,IS-1,KS-1)
!           END IF
!          END IF
!        END IF
C             LAYER K-1, COL J
!          IF (IS.LT.NSROW) THEN
!		 IF(IBOUND(J,I+1,K-1).NE.0) THEN
!	      IF (CONC(JS,IS+1,KS-1).GT.CMAX(JS,IS,KS))
!     *              CMAX(JS,IS,KS)=CONC(JS,IS+1,KS-1)
!	      IF (CAVG(JS,IS+1,KS-1).GT.CMAX(JS,IS,KS))
!     *              CMAX(JS,IS,KS)=CAVG(JS,IS+1,KS-1)
!	      IF (CONC(JS,IS+1,KS-1).LT.CMIN(JS,IS,KS)) 
!     *              CMIN(JS,IS,KS)=CONC(JS,IS+1,KS-1)
!	      IF (CAVG(JS,IS+1,KS-1).LT.CMIN(JS,IS,KS)) 
!     *              CMIN(JS,IS,KS)=CAVG(JS,IS+1,KS-1)
!           END IF
!          END IF
!          IF (IS.GT.1) THEN
!		 IF(IBOUND(J,I-1,K-1).NE.0) THEN
!	      IF (CONC(JS,IS-1,KS-1).GT.CMAX(JS,IS,KS))
!     *              CMAX(JS,IS,KS)=CONC(JS,IS-1,KS-1)
!	      IF (CAVG(JS,IS-1,KS-1).GT.CMAX(JS,IS,KS))
!     *              CMAX(JS,IS,KS)=CAVG(JS,IS-1,KS-1)
!	      IF (CONC(JS,IS-1,KS-1).LT.CMIN(JS,IS,KS)) 
!     *              CMIN(JS,IS,KS)=CONC(JS,IS-1,KS-1)
!	      IF (CAVG(JS,IS-1,KS-1).LT.CMIN(JS,IS,KS)) 
!     *              CMIN(JS,IS,KS)=CAVG(JS,IS-1,KS-1)
!           END IF
!          END IF
!      END IF
C
C        IF DISPERSION REDUCES CONCENTRATION AT CELL,
C            CALCULATE PERCENTAGE REDUCTION BASED ON NORMALIZED
C            RANGE AMONG ADJACENT CELLS
c      IF(SUMMASS(JS,IS,KS).GT.0.0.AND.CNMASS(JS,IS,KS).LT.0.0) 
c     *   CNCPCT(JS,IS,KS)=CNMASS(JS,IS,KS)/(SUMMASS(JS,IS,KS)
c     *      -CMIN(JS,IS,KS)*SUMWT(JS,IS,KS))
c       WRITE (IOUTS,963) JS,IS,KS,CNMASS(JS,IS,KS)
  963 FORMAT(1x,'JS,IS,KS,CNMASS(JS,IS,KS) =',3i3,1pe11.3)
c      if (CONC(JS,IS,KS).LE.CMIN(JS,IS,KS).AND.
c     *CNMASS(JS,IS,KS).LT.0.0) then
c            write(iouts,964) js,is,ks
c      end if
c  964 format(1x,'*** WARNING *** Unexpected condition in MOC5WTAP for ce
c     *ll js,is,ks= ',3i4)
C Initialize PTFLAG (used to determine course of action in PT update loop below)
      PTFLAG(JS,IS,KS)=1
cgzh debug output
c      IF(SUMMASS(JS,IS,KS).LE.0.0.AND.CNMASS(JS,IS,KS).LT.0.0) then
c      write(iouts,*) 'SUMMASS ANOMALY, js,is,ks,summass,cnmass',
c     *  js,is,ks,SUMMASS(JS,IS,KS),CNMASS(JS,IS,KS)
c	end if
C
corig      IF(SUMMASS(JS,IS,KS).GT.0.0.AND.CNMASS(JS,IS,KS).LT.0.0) then
      IF(CNMASS(JS,IS,KS).LT.0.0) then
cgzh debug roland
c we are getting a conc=0 and summass > 0 here for rolands prob, may be ok
c conceptually (? check this) but divide by 0 is not ok), added if statement
cgzh debug
      if(CONC(JS,IS,KS).EQ.0.0.and.summass(JS,IS,KS).GT.0.0) then
	 write(iouts,*) 'conc=0,summass>0,js,is,ks',js,is,ks
c	 write(iouts,*) 'js,is,ks',js,is,ks
c	 write(iouts,*) 'summass',summass(js,is,ks)
c	 write(iouts,*) 'cnmass',cnmass(js,is,ks)
	end if
cgzh roland fix 
       IF(CONC(JS,IS,KS).NE.0.0) THEN
C Check to avoid positive percentage
	  IF ((CONC(JS,IS,KS)-CMIN(JS,IS,KS)).GT.0.0) THEN
          CNCPCT(JS,IS,KS)=CNCNC(JS,IS,KS)/(CONC(JS,IS,KS)
     *       -CMIN(JS,IS,KS))
          PTFLAG(JS,IS,KS)=-2
C Percentage < -1 is illogical, try straight pct
          IF(CNCPCT(JS,IS,KS).LT.-1.0) THEN
		   CNCPCT(JS,IS,KS)=CNCNC(JS,IS,KS)/CONC(JS,IS,KS)
             PTFLAG(JS,IS,KS)=-1
          END IF
	  ELSE
          CNCPCT(JS,IS,KS)=CNCNC(JS,IS,KS)/CONC(JS,IS,KS)
             PTFLAG(JS,IS,KS)=-1
        END IF
       END IF 
C Percentage < -1 is illogical, resort to arithmetic algorithm
        IF(CNCPCT(JS,IS,KS).LT.-1.0) then  
            PTFLAG(JS,IS,KS)=1
        end if
C Percentage > 0 is illogical, resort to arithmetic algorithm,
C Also avoid the pct calc for cells with negative conc
        IF(CNCPCT(JS,IS,KS).GT.0.0.OR.CONC(JS,IS,KS).LT.0.0) then
            PTFLAG(JS,IS,KS)=1
        endif
cgzh debug output
c	if(cncpct(js,is,ks).gt.0.0)then
c	write(iouts,*) 'cncpct gt 0 at js is ks', js, is, ks
c	write(iouts,*) 'CONC,CMIN,CNCNC',CONC(JS,IS,KS),CMIN(JS,IS,KS),
c     * CNCNC(JS,IS,KS)
c	write(iouts,*) 'CAVG j-1,j,j+1',CAVG(JS-1,IS,KS),CAVG(JS,IS,KS),
c     * CAVG(JS+1,IS,KS)
c	end if
	END IF
C
C
C        IF DISPERSION INCREASES CONCENTRATION AT CELL,
C            CALCULATE PERCENTAGE ADJUSTMENT BASED ON NORMALIZED
C            RANGE AMONG ADJACENT CELLS; CALCULATE Cx FACTOR
cgzh debug Because cncnc has cnmass info in it, and that is what we use to alter
c          pconcs, use it here instead (in roland's problem, cncnc=0 while cnmass>0,
c          caused div zero error below
cgzh debug old line      IF(CNMASS(JS,IS,KS).GT.0.0) then
      IF(CNCNC(JS,IS,KS).GT.0.0) then
        DENOM=(CONC(JS,IS,KS)+CNCNC(JS,IS,KS)-CMAX(JS,IS,KS))
C Avoid negative CX (check denom)
	  IF(DENOM.LT.0) THEN
cgzh debug roland
c      if(js.eq.81.and.is.eq.24.and.ks.eq.3.and.iimov.eq.7) then
c	write(*,*) 'b ip,pconc ',ip,pconc(ip)
c	end if
          CX(JS,IS,KS)=(-CONC(JS,IS,KS)*CNCNC(JS,IS,KS)-CNCNC(JS,IS,KS)*
     *                CNCNC(JS,IS,KS))/DENOM
cgzh orig line          PTFLAG(JS,IS,KS)=2
cgzh debug this is to avoid roland's bug, a crash caused by a division by zero
c below due to cx=0.0 and ptflag=2
c also exclude cx<0
          IF(CX(JS,IS,KS).GT.0.0) THEN
            PTFLAG(JS,IS,KS)=2
          ELSE
            PTFLAG(JS,IS,KS)=1
          END IF
cgzh debug output
c      if(cx(js,is,ks).lt.0) then
c	 write(iouts,*) 'cx.lt.0,js,is,ks', cx(JS,IS,KS),js,is,ks
c	end if
c          if(js.eq.1.and.is.eq.1.and.ks.eq.2) then
c	 write(iouts,*) 'case set to', PTFLAG(JS,IS,KS)
c	 write(iouts,*) 'cnmass,cx', CNMASS(JS,IS,KS),CX(JS,IS,KS)
c	end if
        END IF
	END IF
C DEBUG LFK
c      IF(CNMASS(JS,IS,KS).GT.0.0.and.cx(js,is,ks).le.0.0) then
c      WRITE(IOUTS,965) js,is,ks,CMIN(JS,IS,KS),CMAX(JS,IS,KS),
c     *CNCNC(JS,IS,KS),CONC(js,is,ks),CX(JS,IS,KS)
c	end if
c  965 format(1x,'cell,cmin,cmax,CNCNC,CONC,C-X: ',
c     *3i4,1p5e15.8)
C
C
cgzh debug output
c      if(summass(js,is,ks).lt.0) then
c	 write(iouts,*) 'js,is,ks',js,is,ks
c	 write(iouts,*) 'ip,ptwt,pconc'
c	 write(iouts,*) ip,ptwt(IP),pconc(ip)
c	endif
C
cgzh debug output
c      if(js.eq.23.and.is.eq.5.and.iimov.ge.30) then
c      write(iouts,*) 'wtap:  cncnc after update',
c     * CNCNC(JS,IS,KS)
c	  end if   
   65 CONTINUE
CMOCWT  ADD SUMS TO MASS BALANCE ARRAY
      SBVL(3,2)=SUMVOL
      SBVL(4,2)=CUMMASS
cgzh debug
cgzh debug dzz
c       write(iouts,*) 
c       write(iouts,*) 'total cmsinc,cmsdec',cmsinc,cmsdec
c       write(iouts,*) 'mass difference=',cmsinc+cmsdec
c       write(iouts,*) 
c      write(iouts,*) 'cummass in wtap A:',cummass
      SUMVOL=0.0
	CUMMASS=0.0
cgzh debug 8/3 need to zero this out as it is recalced in 180 loop
      SUMMASS=0.0
cgzh temporary summass array
	CUMMASS2=0.0
C     ****************************************************************
C     ---CHANGE CONCENTRATION OF PARTICLES---
       CUMMASS1=0.0
      DO 180 IP=1,NP
      IF(PC(IP).EQ.0.0) GO TO 180
      J=PC(IP)+0.5
      JS=J-ISCOL1+1
      I=ABS(PR(IP))+0.5
      IS=I-ISROW1+1
      K=PL(IP)+0.5
      KS=K-ISLAY1+1
C     ---UPDATE CONC. OF PTS. IN ACTIVE CELLS---
      IF(IBOUND(J,I,K).NE.0) THEN
cgzh temp cummass array
       CUMMASS1=CUMMASS1+PTWT(IP)*PCONC(IP)
C  USE SPECIAL PROPORTIONAL REDUCTION FOR DECREASES
cgzh debug  dan's comment? CAN PROBABLY GET RID OF CNCNC ARRAY IF USING EXPLICIT STUFF
cgzh debug orig lines
c       IF(CNCNC(JS,IS,KS).LT.0.0.AND.
c     * CONC(JS,IS,KS).GT.0.0.AND.CNCPCT(JS,IS,KS).GE.-1.E0) THEN
cgzh  new lines??
cgzh  in old code, checked conc instead of summass here; conc
cgzh  was updated, summass is not -- analogous?
cgzh  perhaps we can check summass.ne.0.0 since using cncpct would
cgzh  *increase* pconcs if they are negative
C
cgzh debug output
c      if(iimov.eq.125.and.ip.eq.31038) then
c        write(*,*)
c        write(*,*) 'PTFLAG(JS,IS,KS)=',PTFLAG(JS,IS,KS)
c        write(*,*) 'CNCNC(JS,IS,KS)=',CNCNC(JS,IS,KS)
c      end if

C Check PTFLAG and act accordingly
       SELECT CASE (PTFLAG(JS,IS,KS))
C PTFLAG=-2  PROPORTIONAL DECREASE WITH BASE=CMIN
       CASE (-2) 
cgzh debug output
c      if(js.eq.1.and.is.eq.1.and.ks.eq.1) write(iouts,*) 'CASE -2,
c     *IP,PCONC,CNCPCT,CMIN',IP,PCONC(IP),CNCPCT(JS,IS,KS),CMIN(JS,IS,KS)
       PCONC(IP)=PCONC(IP)-(CNCPCT(JS,IS,KS)*(CMIN(JS,IS,KS)-PCONC(IP)))
cgzh debug output
c      if(js.eq.1.and.is.eq.1.and.ks.eq.1) write(iouts,*) 'PCONC after',
c     * PCONC(IP)
C
C PTFLAG=-1  PROPORTIONAL DECREASE WITH BASE=0.0
       CASE (-1) 
       PCONC(IP)=PCONC(IP)*(1.E0+CNCPCT(JS,IS,KS))
C
C PTFLAG=1  ARITHMETIC INCREASE/DECREASE 
       CASE (1) 
       PCONC(IP)=PCONC(IP)+CNCNC(JS,IS,KS)
C
C PTFLAG=2  PROPORTIONAL INCREASE WITH CMAX
c
cgzh debug this is where roland's bug comes from:
c during js.eq.79.and.is.eq.14.and.ks.eq.10.and.iimov.eq.7,
c  conc=  1E-45
c cncnc= -1E-45
c    cx=  0.0
c because cctemp just = cncnc, denom of 2nd line is conc+cncnc=0.0, CRASH
       CASE (2) 
       CCTEMP=CNCNC(JS,IS,KS)+CX(JS,IS,KS)
       PCONC(IP)=(PCONC(IP)+CCTEMP)*
     *           (1.0-(CX(JS,IS,KS)/(CONC(JS,IS,KS)+CCTEMP)))

       END SELECT
C
C
cgzh ccbd
C        ---APPLY CONSTANT-CONCENTRATION BOUNDARY PACKAGE---
C  THIS SECTION WILL CHANGE CONCENTRATION OF PARTICLES IN CONSTANT
C  CONCENTRATION BOUNDARY CELLS TO THE VALUE PRESCRIBED BY THE USER.
C  THE NET CHANGE IN MASS FOR EACH SUCH CELL IS COMPUTED AND REPORTED
C  IN THE MASS BALANCE AS EITHER ENTERING OR LEAVING THE SYSTEM.  
C
C  THIS SECTION ACCOUNTS FOR DISPERSION, DP, AND DK (EACH OF THESE ALTERS
C  CNCNC, WHICH WAS JUST APPLIED TO PCONC) 
      IF(INCCBD.GT.0) THEN 
C  IF CCBD IN THIS CELL, ADJUST CONC AND TRACK MASS
        CCCONC=CCBDY(JS,IS,KS)
        IF(CCCONC.GE.0.0) THEN
C  CALCULATE DIFFERENCE BETWEEN NEW AND OLD PARTICLE CONCENTRATION
	   DIFFCONC=CCCONC-PCONC(IP)
C  CALCULATE CHANGE IN MASS DUE TO REASSIGNING PCONC
c
c    positive chngmass is mass added
c    negative chngmass is mass removed
         IF(DIFFCONC.NE.0.0) THEN
           CHNGMASS(JS,IS,KS)=CHNGMASS(JS,IS,KS)+DIFFCONC*PTWT(IP)
C  REASSIGN NEW PARTICLE CONCENTRATION
	     PCONC(IP)=CCCONC
	   END IF
	  END IF        
      END IF
C  END CCBD>0
cgzh debug roland
c      if(js.eq.81.and.is.eq.24.and.ks.eq.3.and.iimov.eq.7) then
c	write(*,*) 'b ip,pconc ',ip,pconc(ip)
c	end if

c      if(ip.eq.4500) then
cgzh debug output
c      write(iouts,*) 'js,is,ks',js,is,ks
c      write(iouts,*) 'case, pconc(4500)',ptflag(js,is,ks), pconc(4500)
c      write(iouts,*) 'cncnc,cx,cnmass',CNCNC(JS,IS,KS),CX(JS,IS,KS),
c     * cnmass(js,is,ks)
c      end if       
cc       IF(CNMASS(JS,IS,KS).LT.0.0.AND.
cc     * SUMMASS(JS,IS,KS).GT.0.0) THEN
c     * SUMMASS(JS,IS,KS).GT.0.0.AND.CNCPCT(JS,IS,KS).GE.-1.E0) THEN
C  FOR REDUCTIONS DROP ALL PARTICLE CONCENTRATIONS PROPORTIONALLY
cc          tmp=PCONC(IP)
cc       PCONC(IP)=PCONC(IP)-(CNCPCT(JS,IS,KS)*(CMIN(JS,IS,KS)-PCONC(IP)))
c         PCONC(IP)=PCONC(IP)*(1.E0+CNCPCT(JS,IS,KS))
c	tmp2=PCONC(IP)
c         PCONC(IP)=PCONC(IP)+CMIN(JS,IS,KS)
cc       IF(
cc     * SUMMASS(JS,IS,KS).LE.0.0.OR.CNCPCT(JS,IS,KS).LT.-1.E0) THEN
cc         WRITE (IOUTS,986)ip,JS,IS,KS,SUMMASS(JS,IS,KS),CNCPCT(JS,IS,KS)
cc	END IF
cc  986 FORMAT (1X,'ip,CELL,SUMMASS.LE.0.AND.CNCPCT.LT.-1 ',4I3,1P2E11.3)
cc       ELSE IF(CNMASS(JS,IS,KS).GT.0.0.and.cx(js,is,ks).gt.0.0) THEN
C  FOR INCREASES, INCREASE PARTICLE CONCENTRATIONS PROPORTIONALLY
cc          tmp=PCONC(IP)
cc      CCTEMP=CNCNC(JS,IS,KS)+CX(JS,IS,KS)
cc      PCONC(IP)=(PCONC(IP)+CCTEMP)*
cc     *           (1.0-(CX(JS,IS,KS)/(CONC(JS,IS,KS)+CCTEMP)))
Cold  FOR OTHER CASES, ADD NODE CHANGE TO PARTICLES
c         PCONC(IP)=PCONC(IP)+CNCNC(JS,IS,KS)
cc         PCOLD=PCONC(IP)+CNCNC(JS,IS,KS)
c	WRITE(IOUTS,987) ip,js,TMP,PCOLD,PCONC(IP)
cc  987 FORMAT(1X,'ip,js,TMP,PCOLD,PCONC(IP) ',2i3,1P3E11.3)
cc       ELSE
c	IF (CNCNC(JS,IS,KS).NE.0.0.OR.CNMASS(JS,IS,KS).NE.0.0) then
c       WRITE (IOUTS,988) IP,JS,CNCNC(JS,IS,KS),CNMASS(JS,IS,KS),
c     8 conc(js,is,ks)
c	 end if
cc  988 FORMAT (1X,'EXCEPTION NOTED PT #,CELL JS & CNCNC,CNMASS', 2I5,
cc     *1P3E11.3)
Cold  FOR OTHER CASES, ADD NODE CHANGE TO PARTICLES
cc         PCONC(IP)=PCONC(IP)+CNCNC(JS,IS,KS)
cc       END IF
CMOCWT  SUM WEIGHTS AND MASS AFTER DISPERSION APPLIED
       SUMVOL=SUMVOL+PTWT(IP)
cgzh debug
       SUMPTWT(JS,IS,KS)=SUMPTWT(JS,IS,KS)+PTWT(IP)
       CUMMASS=CUMMASS+PTWT(IP)*PCONC(IP)
cgzh debug output
c      if(js.eq.1.and.is.eq.2.and.iimov.eq.5) 
c     * write(71,*) 'ip,mass',ip,PTWT(IP)*PCONC(IP)
c      if(js.eq.2.and.is.eq.1.and.iimov.eq.2) 
c     * write(72,*) 'ip,mass',ip,PTWT(IP)*PCONC(IP)
       SUMMASS(JS,IS,KS)=SUMMASS(JS,IS,KS)+PTWT(IP)*PCONC(IP)
cgzh temp summass array
       CUMMASS2(JS,IS,KS)=CUMMASS2(JS,IS,KS)+PTWT(IP)*PCONC(IP)
      END IF
cgzh debug output
c      if(js.eq.1.and.is.eq.1.and.ks.eq.1) then
c      write(iouts,*) 'B: sumwt,summass for ip=',ip, 
c     * sumwt(js,is,ks),summass(js,is,ks)
c	end if
  180 CONTINUE
C
C  LOOP OVER CELLS TO SUM MASS ADDED OR REMOVED VIA CCBD PACKAGE
      IF(INCCBD.GT.0) THEN 
       TOTIN=0.D0
	 TOTOUT=0.D0
       DO 2111 KS=1,NSLAY
       DO 2111 IS=1,NSROW
       DO 2111 JS=1,NSCOL
        DIFFMASS=CHNGMASS(JS,IS,KS)
	  IF(DIFFMASS.GT.0.D0) THEN
          TOTIN=TOTIN+DIFFMASS
        ELSEIF(DIFFMASS.LT.0.D0) THEN
          TOTOUT=TOTOUT+DIFFMASS
        END IF
 2111  CONTINUE
C
C  UPDATE SBVL ARRAY
       SBVL(1,26)=SBVL(1,26)+TOTIN
       SBVL(2,26)=SBVL(2,26)+TOTOUT
C
      END IF
C  END CCBD>0
cgzh debug
c      write(iouts,*) 'cummass in wtap',cummass
      DO 465 KS=1,NSLAY
      DO 465 IS=1,NSROW
      DO 465 JS=1,NSCOL
cgzh debug update summass for diff calc
c        summass(js,is,ks)=summass(js,is,ks)+cnmass(js,is,ks)
c
c        diff=(summass(js,is,ks)-cummass2(js,is,ks))
        diff=abs(summass(js,is,ks)-cummass2(js,is,ks))
c	  IF(diff.ne.0.0) then
c	  IF(diff.gt.1.0e-4) then
c	  IF((diff/summass(js,is,ks)).gt.1.0e-5) then
c	  IF(js.eq.23.and.is.eq.1.and.ks.eq.2) then
cgzh deubg check this with aqu2k
c          write(iouts,*) 'diff at js,is,ks', diff,js,is,ks
c          write(iouts,*) 'cnmass,cncpct', cnmass(js,is,ks),
c     *        cncpct(js,is,ks)
c	  IF(diff.gt.1.0e-6) then
c      if(summass(js,is,ks).gt.0.0) then
c          write(iouts,*) 'summass,cummass2,diff', summass(js,is,ks),
c     * cummass2(js,is,ks),diff
c      if(js.eq.2.and.is.eq.1) then
c          write(iouts,*) 'B: js,is,ks,sumwt,summass,cnmass', 
c     * js,is,ks,sumwt(js,is,ks),summass(js,is,ks),cnmass(js,is,ks)
c	  end if   
c	  end if   
c
      K=KS+ISLAY1-1
      I=IS+ISROW1-1
      J=JS+ISCOL1-1
cgzh debug  compare SUMWT and SUMPTWT
c      rat=0.0
c      diffv=SUMWT(JS,IS,KS)-SUMPTWT(JS,IS,KS)
c	IF(SUMWT(JS,IS,KS).GT.0) rat=diffv/SUMWT(JS,IS,KS)
c	IF(rat.gt.1E-4) THEN
c      if(js.eq.17.and.is.eq.14.and.ks.eq.2) then
c        write(iouts,*) 'SUMWT vs SUMPTWT WARNING'
c        write(iouts,*) 'JS,IS,KS',JS,IS,KS
c        write(iouts,*) 'SUMWT,SUMPTWT',SUMWT(JS,IS,KS),
c     * SUMPTWT(JS,IS,KS)
c        write(iouts,*) 'rat,diffv',rat,diffv
c	END IF
cgzh debug end
      IF(IBOUND(J,I,K).NE.0) THEN
C       UPDATE SUMMASS 
        SUMMASS(JS,IS,KS)=CUMMASS2(JS,IS,KS)
C       UPDATE CONCENTRATION ARRAY USING PARTICLE INFO
        IF(SUMWT(JS,IS,KS).GT.0.0) THEN
          CONC(JS,IS,KS)=SUMMASS(JS,IS,KS)/SUMWT(JS,IS,KS)
        ELSE
          CONC(JS,IS,KS)=0.0
        END IF
cgzh ccbd
      END IF
465   CONTINUE
C
CMOCWT  ADD SUMS TO MASS BALANCE ARRAY
      SBVL(3,1)=SUMVOL
      SBVL(4,1)=CUMMASS
cgzh debug output
c      write(iouts,*) 'sumcnc,sumcnm=',sumcnc,sumcnm
C  RELEASE MEMORY
cgzh debug output roland
c      if(iimov.eq.14) then 
c	  write(*,*) 'B: wtap pconc(761)',pconc(761)
c	end if
cgzh debug output roland
      DEALLOCATE(CNMASS,CNCPCT)
      DEALLOCATE(CMAX,CMIN,CX)
cgzh debug
      DEALLOCATE(cummass2)
cgzh debug
      DEALLOCATE(SUMPTWT)
cgzh debug
      DEALLOCATE(PTFLAG)
cgzh ccbd
      DEALLOCATE(CHNGMASS)
C     ****************************************************************
      RETURN
C     ****************************************************************
      END
C
C
C  PTWT1BOOM !  
C*************************************************************************
C
      SUBROUTINE PTWT1BOOM(IBOUND,
cgzh debug
     *  imov,
     *  PC,PR,PL,PCONC,
     *  SUMWT,PTWT,CELVOL,
     *  VC,VR,VL,
     *  IPTID,PNEWC,PNEWR,PNEWL,
     *  NPCELL,SUMMASS,
     *  LIMBO,NLIMBO,
     *  NSCOL,NSROW,NSLAY,NPMAX,NEWPTS,
     *  NCOL,NROW,NLAY,IOUTS,NP,
cgzh varpt
     *  INIPDL,INIPDA,PCORIG,PRORIG,PLORIG,NPTLAYA,NPTROWA,NPTCOLA,IDIM)
C
C*************************************************************************
C
C  "EXPLODE" PARTICLES UPGRADIENT FROM CELLS WITH ZERO PARTICLES
C
C TEMPORARY ARRAY
cgzh debug double ptwt, sumwt
      DOUBLE PRECISION CELVOL
      DOUBLE PRECISION PTWT,SUMWT,TEMW
      ALLOCATABLE IEXPLODE(:,:,:)
      DIMENSION
     *  IBOUND(NCOL,NROW,NLAY),
     *  PC(NPMAX),PR(NPMAX),PL(NPMAX),PCONC(NPMAX),
     *  NPCELL(NSCOL,NSROW,NSLAY),
     *  SUMMASS(NSCOL,NSROW,NSLAY),CELVOL(NSCOL,NSROW,NSLAY),
     *  SUMWT(NSCOL,NSROW,NSLAY),PTWT(NPMAX),
     *  VC(NSCOL+1,NSROW,NSLAY),VR(NSCOL,NSROW+1,NSLAY),
     *  VL(NSCOL,NSROW,NSLAY+1),
     *  IPTID(NPMAX),
     *  PNEWC(NEWPTS),PNEWR(NEWPTS),PNEWL(NEWPTS),
     *  LIMBO(NLIMBO)
cgzh varpt
      DIMENSION PCORIG(NPMAX),PRORIG(NPMAX),PLORIG(NPMAX)
      DIMENSION NPTCOLA(NSCOL,NSROW,NSLAY),NPTROWA(NSCOL,NSROW,NSLAY),
     *          NPTLAYA(NSCOL,NSROW,NSLAY)
C
      COMMON /SUBGRD/
     *  ISCOL1,ISCOL2,ISROW1,ISROW2,ISLAY1,ISLAY2,ISUBGD
C
C*************************************************************************
C
	ALLOCATE(IEXPLODE(NSCOL,NSROW,NSLAY))
C  INITIALIZE IEXPLODE=0 --> DO NOT EXPLODE PARTICLES IN THIS CELL
cgzh debug output
c      write(iouts,*) 'NLIMBO,NP before explode=',NLIMBO,np
      BOOMCRIT=1.0E-8
	IEXPLODE=0
C  IXFLAG=0 --> NO PARTICLES WILL BE EXPLODED ANYWHERE 
	IXFLAG=0
C
      DO 65 KS=1,NSLAY
      K=KS+ISLAY1-1
      DO 65 IS=1,NSROW
      I=IS+ISROW1-1
      DO 65 JS=1,NSCOL
      J=JS+ISCOL1-1
      IF(IBOUND(J,I,K).EQ.0.OR.NPCELL(JS,IS,KS).GT.0) GO TO 65
C
      IF(INIPDL.EQ.0.AND.INIPDA.EQ.0) THEN
        NPTPND=NEWPTS-1
      ELSE
cgzh varpt
        NPTPND=NPTCOLA(JS,IS,KS)*NPTROWA(JS,IS,KS)*NPTLAYA(JS,IS,KS)
      END IF
C  NO PARTICLES IN CELL, SO CHECK AROUND FOR STRONGEST UPGRADIENT CONTRIBUTOR
        MAXQ=0.0                                                           
        IEX=0                                                          
cgzh debug
c       write(iouts,*) 'PTWT1BOOM: NPCELL=0 at: ', js,is,ks
C  IF ONLY ONE COLUMN IN FLOW GRID, SKIP TO ROWS
        IF (NCOL.EQ.1) GO TO 20
C  COLUMN-WISE FLUXES
C  LEFT-SIDE FACE: POSITIVE VALUE SIGNIFIES ENTERING CELL FROM LEFT
        Q=VC(JS,IS,KS)
	  IF (Q.GT.MAXQ.AND.JS.GT.1) THEN
	    IEX=1
          MAXQ=Q
        END IF
C  RIGHT-SIDE FACE (JS+1): NEGATIVE VALUE SIGNIFIES ENTERING CELL FROM RIGHT
        Q=VC(JS+1,IS,KS)                                    
	  IF (-Q.GT.MAXQ.AND.JS.LT.NSCOL) THEN
          IEX=2
          MAXQ=-Q
        END IF
  20    IF (NROW.EQ.1) GO TO 30
C  ROW-WISE FLUXES
        Q=VR(JS,IS,KS) 
	  IF (Q.GT.MAXQ.AND.IS.GT.1) THEN
          IEX=3
          MAXQ=Q
        END IF
        Q=VR(JS,IS+1,KS)                                   
	  IF (-Q.GT.MAXQ.AND.IS.LT.NSROW) THEN
          IEX=4
          MAXQ=-Q
        END IF
  30    IF (NLAY.EQ.1) GO TO 40
C  LAYER-WISE FLUXES
        Q=VL(JS,IS,KS)
	  IF (Q.GT.MAXQ.AND.KS.GT.1) THEN 
          IEX=5
          MAXQ=Q
        END IF
        Q=VL(JS,IS,KS+1)
	  IF (-Q.GT.MAXQ.AND.KS.LT.NSLAY) IEX=6
  40    SELECT CASE (IEX)
        CASE (0)                          
cgzh debug
c           write(iouts,*) 'js,is,ks',js,is,ks
c           write(iouts,*) 'back velos',VC(JS,IS,KS),VR(JS,IS,KS),
c     * VL(JS,IS,KS)
c           write(iouts,*) 'forw velos',VC(JS+1,IS,KS),VR(JS,IS+1,KS),
c     * VL(JS,IS,KS+1)
           STOP '***ERROR IN PTWT1BOOM! NO FLOW INTO CELL WITH ZERO PTS'
        CASE (1)                          
C  ONLY WANT TO EXPLODE PARTICLES IF THEY EXIST,
C  AND ONLY IF IT WILL INCREASE NPCELL & ONLY IF SUMWT IS NONTRIVIAL
cgzh debug   ---> LT or LE??
c  LT gave pts more time to enter empty cell...
cgzh debug....or get rid of NPTPND check altogether?  may want to revisit RMA
cgzh debug    case with exploding before making this final.  this was better 
cgzh debug    for becker case
cgzh debug update 9/1/2004: for RMA case this caused explosions to happen
cgzh debug   at every move at some cells, which "trapped" pts there (bad).
cgzh debug   Thus this was switched back to include NPTPND check (becker case
cgzh debug   and similar will benefit from random-pt placement perhaps? 
           IF(NPCELL(JS-1,IS,KS).GT.0.AND.
     *	    NPCELL(JS-1,IS,KS).LT.NPTPND.AND.
     *        (SUMWT(JS-1,IS,KS)/CELVOL(JS-1,IS,KS)).GT.BOOMCRIT) THEN
c           IF(NPCELL(JS-1,IS,KS).GT.0) THEN
		   IEXPLODE(JS-1,IS,KS)=1
	       IXFLAG=1
           END IF
        CASE (2)                          
           IF(NPCELL(JS+1,IS,KS).GT.0.AND.
     *	    NPCELL(JS+1,IS,KS).LT.NPTPND.AND.
     *        (SUMWT(JS+1,IS,KS)/CELVOL(JS+1,IS,KS)).GT.BOOMCRIT) THEN
c           IF(NPCELL(JS+1,IS,KS).GT.0) THEN
		   IEXPLODE(JS+1,IS,KS)=1
	       IXFLAG=1
	     END IF
        CASE (3)                          
           IF(NPCELL(JS,IS-1,KS).GT.0.AND.
     *	    NPCELL(JS,IS-1,KS).LT.NPTPND.AND.
     *        (SUMWT(JS,IS-1,KS)/CELVOL(JS,IS-1,KS)).GT.BOOMCRIT) THEN
c           IF(NPCELL(JS,IS-1,KS).GT.0) THEN
             IEXPLODE(JS,IS-1,KS)=1
             IXFLAG=1
	     END IF
        CASE (4)                          
           IF(NPCELL(JS,IS+1,KS).GT.0.AND.
     *	    NPCELL(JS,IS+1,KS).LT.NPTPND.AND.
     *        (SUMWT(JS,IS+1,KS)/CELVOL(JS,IS+1,KS)).GT.BOOMCRIT) THEN
c           IF(NPCELL(JS,IS+1,KS).GT.0) THEN
             IEXPLODE(JS,IS+1,KS)=1
	       IXFLAG=1
	     END IF
        CASE (5)                          
           IF(NPCELL(JS,IS,KS-1).GT.0.AND.
     *	    NPCELL(JS,IS,KS-1).LT.NPTPND.AND.
     *        (SUMWT(JS,IS,KS-1)/CELVOL(JS,IS,KS-1)).GT.BOOMCRIT) THEN
c           IF(NPCELL(JS,IS,KS-1).GT.0) THEN
             IEXPLODE(JS,IS,KS-1)=1
	       IXFLAG=1
	     END IF
        CASE (6)                          
           IF(NPCELL(JS,IS,KS+1).GT.0.AND.
     *	    NPCELL(JS,IS,KS+1).LT.NPTPND.AND.
     *        (SUMWT(JS,IS,KS+1)/CELVOL(JS,IS,KS+1)).GT.BOOMCRIT) THEN
c           IF(NPCELL(JS,IS,KS+1).GT.0) THEN
             IEXPLODE(JS,IS,KS+1)=1
	       IXFLAG=1
	     END IF
        END SELECT
   65 CONTINUE
C  SKIP REST IF NO EXPLOSIONS
      IF (IXFLAG.EQ.0) THEN
           WRITE(IOUTS,*) 
           WRITE(IOUTS,*)  'NZERO > 0, BUT'
           WRITE (IOUTS,*) 'NO CELLS MET EXPLOSION CRITERIA'
           WRITE(IOUTS,*) 
  	     GO TO 999
	END IF
C     ****************************************************************
C     REMOVE PARTICLES FROM CELLS TO BE "EXPLODED"
C     NPCELL WILL BE UPDATED IN ADDPTS
      SUMMASS=0.0
      DO 180 IP=1,NP
      IF(PC(IP).EQ.0.0) GO TO 180
      J=PC(IP)+0.5
      JS=J-ISCOL1+1
      I=ABS(PR(IP))+0.5
      IS=I-ISROW1+1
      K=PL(IP)+0.5
      KS=K-ISLAY1+1
      IF(IEXPLODE(JS,IS,KS).EQ.1) THEN
	   SUMMASS(JS,IS,KS)=SUMMASS(JS,IS,KS)+ptwt(ip)*pconc(ip)
cgzh debug
c         write(iouts,*) 'Before exploding, particle ip removed from', 
c     *   ip,js,is,ks
         PC(IP)=0.0
         PR(IP)=0.0
         PL(IP)=0.0
         PCONC(IP)=0.0
	   PTWT(IP)=0.0
C  
         DO 1570 ID=1,NLIMBO
           IF(LIMBO(ID).GT.0) GO TO 1570
           LIMBO(ID)=IP
           GO TO 1580
 1570    CONTINUE
 1580  CONTINUE
      END IF
  180 CONTINUE
C
C ADD PTS
C SAVE NUMBER OF PARTICLES BEFORE ADDING
      NPTM=NP
      DO 165 KS=1,NSLAY
      DO 165 IS=1,NSROW
      DO 165 JS=1,NSCOL
      IF(IEXPLODE(JS,IS,KS).EQ.1) THEN
C USE CONC = AVG CONC ON PTS
C USE VOLUME = SUM OF WEIGHTS OF PTS
cgzh debug
c      WRITE(IOUTS,*) 
c      WRITE(IOUTS,*)'Calling ADDPTS: Exploding pts'
c      WRITE(IOUTS,*) 'Creating',NPTPND,' new particles at (js,is,ks):'
c      WRITE(IOUTS,*) js,is,ks
c      WRITE(IOUTS,*) 'SUMWT=',SUMWT(JS,IS,KS)
c      WRITE(IOUTS,*) 'SUMMASS=',SUMMASS(JS,IS,KS)
c      WRITE(IOUTS,*)
        IF(SUMWT(JS,IS,KS).GT.0.0) THEN
	   TEMC=SUMMASS(JS,IS,KS)/SUMWT(JS,IS,KS)
	   TEMW=SUMWT(JS,IS,KS)
cgzh varpt 
         IF(INIPDL.EQ.0.AND.INIPDA.EQ.0) THEN
           CALL ADDPTS(PC,PR,PL,PCONC,TEMC,IPTID,NPCELL,
     *        IBOUND,PNEWC,PNEWR,PNEWL,
     *        PTWT,TEMW,
     *        NCOL,NROW,NLAY,NSCOL,NSROW,NSLAY,
     *        NEWPTS,NPMAX,
     *        JS,IS,KS,
     *        IOUTS,NPTM,WTFAC)
         ELSE
cgzh varpt 
cgzh get particle distribution for this cell
           NPTCOL=NPTCOLA(JS,IS,KS)
           NPTROW=NPTROWA(JS,IS,KS)
           NPTLAY=NPTLAYA(JS,IS,KS)
           CALL ADDPTSVAR(PC,PR,PL,PCONC,TEMC,
     *        NPCELL,PCORIG,PRORIG,PLORIG,
     *        PTWT,TEMW,
     *        NSCOL,NSROW,NSLAY,
     *        NPMAX,NPTCOL,NPTROW,NPTLAY,
     *        JS,IS,KS,
     *        IOUTS,NPTM,IDIM,WTFAC)
         END IF
        END IF
	END IF
  165 CONTINUE
cgzh debug output
c      write(iouts,*) 'NLIMBO,NPTM mid-explode=',NLIMBO,nptm
C        ---INSERT PARTICLES INTO LIMBO LOCATIONS---
C  START WITH LAST PARTICLE ADDED, WHICH HAS AN ID = NPTM
      IP=NPTM
      DO 595 IL=1,NLIMBO
      IPL=LIMBO(IL)
C  LOOK FOR NON-ZERO ID NUMBERS THAT WERE STORED IN LIMBO
      IF(IPL.EQ.0) GO TO 595
C  IF THERE IS AN ID IN LIMBO, USE IT BY SAVING THE INFO
C    ABOUT THE PARTICLE THAT WAS CREATED IN THAT ID SPOT
      PR(IPL)=PR(IP)
      PR(IP)=0.0
      PC(IPL)=PC(IP)
      PC(IP)=0.0
      PL(IPL)=PL(IP)
      PL(IP)=0.0
      PCONC(IPL)=PCONC(IP)
      PCONC(IP)=0.0
	PTWT(IPL)=PTWT(IP)
	PTWT(IP)=0.0
      IPTID(IPL)=IPTID(IP)
      IPTID(IP)=0
      LIMBO(IL)=0
cgzh debug output
c	write(iouts,*) 'IP put into IPL',IP,IPL
C  GO BACK TO THE NEXT PARTICLE THAT WAS CREATED
      IP=IP-1
C  IF IP=NP, NOT A PARTICLE THAT WAS CREATED IN THIS ROUTINE
      IF(IP.EQ.NP) GOTO 596
  595 CONTINUE
C        ---ADJUST NUMBER OF PARTICLES---
C  OUT OF LOOP, SET THE NUMBER OF PARTICLE SPOTS USED 
C    THIS WILL BE SMALLER IF SOME NEW PARTICLES WERE INSERTED INTO
C    LIMBO LOCATIONS
  596 NP=IP
cgzh debug output
c      write(iouts,*) 'NLIMBO,NP after explode=',NLIMBO,np
C
C  RELEASE MEMORY
  999 DEALLOCATE(IEXPLODE)
C     ****************************************************************
      RETURN
C     ****************************************************************
      END
C
C SMOC6MWT    PRINT OUTPUT FOR MASS BALANCE--WEIGHTED PARTICLES
C*************************************************************************
C
      SUBROUTINE SMOC6MWT(SBVL,IUNIT,SRCDCY,TIMV,
     * IOUTS,KPER,NPER,KSTP,NSTP,IMOV,NMOV,SUMTCH,ICONLY,
     * INDK,IDKZO,IDKFO,IDKZS,IDKFS,
     * INAGE,
     * INDP,IDPZO,IDPFO,INSFRUNIT,INLAKUNIT,INDRT,NIUNIT,DECAY,
     * MULTSS,INMNW,INCCBD)
C
cgzh debug double sbvl
      DOUBLE PRECISION SBVL,TEMPSBVL
C TEMPORARY ARRAYS
      ALLOCATABLE TEMPSBVL(:,:)
      DIMENSION SBVL(6,NIUNIT),IUNIT(NIUNIT)
      COMMON /SUBGRD/
     *  ISCOL1,ISCOL2,ISROW1,ISROW2,ISLAY1,ISLAY2,ISUBGD
      DOUBLE PRECISION DECAY
cgzh debug double mass balance numbers
      DOUBLE PRECISION CSTM2,TOTMIN,TOTMOT,RESID,TIN,TOUT,
     *  DENOM,ERR,SMIN,SMPR,ERR2
CMOCWT
      INCLUDE 'ptwt.inc'
C ALLOCATE TEMPORARY ARRAYS
      ALLOCATE(TEMPSBVL(6,NIUNIT))
C
C*************************************************************************
C
C  ZERO ACCUMULATORS
      TOTMIN=0.0
      TOTMOT=0.0
C  ADD MASS FLUX FROM DECAY FROM SOURCES TO THE TOTAL MASS OUT
cgzh decayed src never in aquifer, don't include in amount out
c      TOTMOT=TOTMOT+SRCCUM
C  accumulated in SRCDCY, no need for srccum any more
c      SRCCUM=SRCDCY*TIMV
C  ADD DECAY TERMS
      TOTMIN=TOTMIN+SBVL(3,3)
      TOTMOT=TOTMOT+SBVL(4,3)
C  LOOP THROUGH PACKAGES, ADDING APPROPRIATE MASS FLUXES
      DO 50 L=4,12
         TOTMIN=TOTMIN+SBVL(1,L)
         TOTMOT=TOTMOT+SBVL(4,L)
 50      CONTINUE
C  SIMPLE REACTIONS SINK/SOURCES AND AGE MASS INCREASE
      DO 55 L=13,17
        TOTMIN=TOTMIN+SBVL(1,L)
        TOTMOT=TOTMOT+SBVL(2,L)
 55   CONTINUE
C  DOUBLE POROSITY DIFFUSION SINK/SOURCES
      DO 56 L=19,20
        TOTMIN=TOTMIN+SBVL(1,L)
        TOTMOT=TOTMOT+SBVL(2,L)
 56   CONTINUE
C  Lake and Stream Packages
      DO 58 L=21,22
        TOTMIN=TOTMIN+SBVL(1,L)
        TOTMOT=TOTMOT+SBVL(2,L)
 58   CONTINUE
C  DRT Package
      DO 60 L=23,23
        TOTMIN=TOTMIN+SBVL(1,L)
        TOTMOT=TOTMOT+SBVL(2,L)
 60   CONTINUE
C  MNW Package
      DO 61 L=24,24
        TOTMIN=TOTMIN+SBVL(1,L)
        TOTMOT=TOTMOT+SBVL(4,L)
 61   CONTINUE
C  CCBD Package
      DO 62 L=26,26
        TOTMIN=TOTMIN+SBVL(1,L)
        TOTMOT=TOTMOT+SBVL(2,L)
 62   CONTINUE
C  CALCULATE CHANGE IN MASS STORED
cgzh orig       CSTM2=SBVL(1,1)-SBVL(2,1)+SBVL(1,2)-SBVL(2,2)
      CSTM2=SBVL(4,1)-SBVL(1,1)+SBVL(2,2)-SBVL(1,2)
cgzh debug output
c      if(imov.eq.8) then
c      write(iouts,*) 'SBVL(1,1),SBVL(4,1),SBVL(4,5)',
c     * SBVL(1,1),SBVL(4,1),SBVL(4,5)
c	end if
corig      IF(INDP.GT.0) CSTM2=CSTM2+SBVL(1,18)-SBVL(2,18)
      IF(INDP.GT.0) CSTM2=CSTM2-SBVL(1,18)+SBVL(2,18)
!      WRITE (IOUTS,100)
cgzh ssfix 
C     
!      IF(MULTSS.EQ.1) WRITE(IOUTS,*) 
!     * '***MASS BALANCE FOR CURRENT STRESS PERIOD ONLY***',
!     * '      (CUMULATIVE BUDGET PRINTED BELOW)'
      WRITE (IOUTS,*) 
      WRITE (IOUTS,105) KPER,NPER,KSTP,NSTP,IMOV,NMOV
      WRITE (IOUTS,107) SUMTCH
cgzh mnw
      IF(INMNW.NE.0) THEN
       WRITE(IOUTS,*) 
       WRITE(IOUTS,*) '     External MNW mass flux (based on wellhead
     & flow) (L**3)(M/VOL)'
       WRITE(IOUTS,*) '     -----------------------------------------
     &--------------------'
       WRITE(IOUTS,'(A,1PE11.4)')
     &'       Cumulative mass flux into aquifer by MNWs   = ',SBVL(1,25)
       WRITE(IOUTS,'(A,1PE11.4)')
     &'       Cumulative mass flux out of aquifer by MNWs = ',SBVL(2,25)
       WRITE(IOUTS,*) 
      END IF
c
      WRITE (IOUTS,110) SBVL(1,1),SBVL(1,2),SBVL(4,1),SBVL(2,2)
CMOCWT
cgzh debug commented these 2 for training class and GW_Chart
!      WRITE (IOUTS,210) SBVL(4,1)
!      WRITE (IOUTS,310) SBVL(4,2)
cgzh debug output  volume report
cgzh debug commented these 2 for training class and GW_Chart
!      WRITE (IOUTS,410) SBVL(3,1)
!      WRITE (IOUTS,411) SBVL(3,2)
      IF(INDP.GT.0) WRITE (IOUTS,112) SBVL(1,18),SBVL(2,18)
      WRITE (IOUTS,111) CSTM2
cgzh old way      WRITE (IOUTS,115) (SBVL(1,L),L=3,12)
      WRITE (IOUTS,115)
      IF(DECAY.NE.0.) WRITE (IOUTS,503) SBVL(3,3)
      WRITE (IOUTS,504) SBVL(1,4)
      IF(ISUBGD.EQ.1) WRITE (IOUTS,505) SBVL(1,5)
      IF(IUNIT(8).GT.0) WRITE (IOUTS,506) SBVL(1,6)
      IF(IUNIT(2).GT.0) WRITE (IOUTS,507) SBVL(1,7)
      IF(IUNIT(4).GT.0) WRITE (IOUTS,508) SBVL(1,8)
      IF(IUNIT(3).GT.0) WRITE (IOUTS,509) SBVL(1,9)
      IF(IUNIT(7).GT.0) WRITE (IOUTS,510) SBVL(1,10)
      IF(IUNIT(5).GT.0) WRITE (IOUTS,511) SBVL(1,11)
      IF(IUNIT(16).GT.0) WRITE (IOUTS,512) SBVL(1,12)
cgzh
      IF(INSFRUNIT.GT.0) WRITE (IOUTS,133) SBVL(1,21)
      IF(INLAKUNIT.GT.0) WRITE (IOUTS,134) SBVL(1,22)
      IF(INDK.GT.0) THEN
        IF(IDKZO.EQ.1) WRITE (IOUTS,116) SBVL(1,13)
        IF(IDKFO.EQ.1) WRITE (IOUTS,117) SBVL(1,14)
        IF(IDKZS.EQ.1) WRITE (IOUTS,118) SBVL(1,15)
        IF(IDKFS.EQ.1) WRITE (IOUTS,119) SBVL(1,16)
      END IF
      IF(INAGE.GT.0) WRITE (IOUTS,120) SBVL(1,17)
      IF(INDP.GT.0) THEN
        IF(IDPZO.EQ.1) WRITE (IOUTS,121) SBVL(1,19)
        IF(IDPFO.EQ.1) WRITE (IOUTS,122) SBVL(1,20)
      END IF
      IF(INDRT.GT.0) WRITE (IOUTS,137) SBVL(1,23)
      IF(INMNW.GT.0) WRITE (IOUTS,140) SBVL(1,24)
      IF(INCCBD.GT.0) WRITE (IOUTS,141) SBVL(1,26)
      WRITE (IOUTS,123) TOTMIN
CMOCWT
cgzh old way      WRITE (IOUTS,125) (SBVL(4,L),L=3,12)
      WRITE (IOUTS,125)
      IF(DECAY.NE.0.) WRITE (IOUTS,503) SBVL(4,3)
      WRITE (IOUTS,504) SBVL(4,4)
      IF(ISUBGD.EQ.1) WRITE (IOUTS,505) SBVL(4,5)
      IF(IUNIT(8).GT.0) WRITE (IOUTS,506) SBVL(4,6)
      IF(IUNIT(2).GT.0) WRITE (IOUTS,507) SBVL(4,7)
      IF(IUNIT(4).GT.0) WRITE (IOUTS,508) SBVL(4,8)
      IF(IUNIT(3).GT.0) WRITE (IOUTS,509) SBVL(4,9)
      IF(IUNIT(7).GT.0) WRITE (IOUTS,510) SBVL(4,10)
      IF(IUNIT(5).GT.0) WRITE (IOUTS,511) SBVL(4,11)
      IF(IUNIT(16).GT.0) WRITE (IOUTS,512) SBVL(4,12)
cgzh
      IF(INSFRUNIT.GT.0) WRITE (IOUTS,135) SBVL(2,21)
      IF(INLAKUNIT.GT.0) WRITE (IOUTS,136) SBVL(2,22)
      IF(INDK.GT.0) THEN
        IF(IDKZO.EQ.1) WRITE (IOUTS,116) SBVL(2,13)
        IF(IDKFO.EQ.1) WRITE (IOUTS,117) SBVL(2,14)
        IF(IDKZS.EQ.1) WRITE (IOUTS,118) SBVL(2,15)
        IF(IDKFS.EQ.1) WRITE (IOUTS,119) SBVL(2,16)
      END IF
      IF(INDP.GT.0) THEN
        IF(IDPZO.EQ.1) WRITE (IOUTS,121) SBVL(2,19)
        IF(IDPFO.EQ.1) WRITE (IOUTS,122) SBVL(2,20)
      END IF
      IF(INDRT.GT.0) WRITE (IOUTS,138) SBVL(2,23)
      IF(INMNW.GT.0) WRITE (IOUTS,140) SBVL(4,24)
      IF(INCCBD.GT.0) WRITE (IOUTS,141) SBVL(2,26)
      WRITE (IOUTS,126) TOTMOT
      IF(DECAY.NE.0.) WRITE (IOUTS,139) SRCDCY
C  CALCULATE RESIDUAL
cgzh initialize ERR in case of no solute at all in system
      ERR=0.0
cgzh orig      RESID=TOTMIN+TOTMOT+CSTM2
cgzh debug keep source decay as separate itemization, but must be in resid calc
      RESID=TOTMIN+TOTMOT+SRCDCY-CSTM2
cgzh debug output
c      if(imov.gt.8) then
c      write(iouts,*) 'totmin,totmot,cstm2',totmin,totmot,cstm2
c	end if
c orig      TIN=ABS(TOTMIN)
cgzh for error calc, take decayed source out of total mass in
      TIN=ABS(TOTMIN)+SRCDCY
      TOUT=ABS(TOTMOT)
C  ZERO MASS BALANCE FORMULA FLAGS
      IMBF=0
      IMBF2=0
      IPREC=0
C  CHECK FLAGS FOR MASS FLUXES, CALCULATE WITH ACCORDING
C  FORMULA
      IF(((ICONLY.EQ.1).AND.(SBVL(1,1).NE.0.0)).OR.
     *   ((TIN.EQ.0.0).AND.(TOUT.EQ.0.0))) GOTO 97
cgzh mbprec
c check CSTM2 vs present mass, if result is less than precision,
c don't use the flux in/out error as it will not be close enough       
      PRECSM=SBVL(4,1)*1E-7
	IF(ABS(CSTM2).LT.PRECSM) THEN
        IPREC=1
        GO TO 97
      END IF
c
      IF(TIN.GT.TOUT) THEN
         DENOM=TOTMIN
         IMBF=1
      ELSE
         DENOM=TOTMOT
         IMBF=2
      ENDIF
cgzh debug output
c      write(iouts,*) 'imbf,denom',imbf,denom
      ERR=(RESID*100.0)/DENOM
  97  IF(SBVL(1,1).EQ.0.) GOTO 95
C  SMIN=STORED MASS INITIALLY
      SMIN=SBVL(1,1)+SBVL(1,2)
C  SMPR=STORED MASS PRESENT
cgzh new spot for present mass (4,1) -- from ptwt+pconc
cgzh new spot for present mass (4,2) -- from sumc
      SMPR=SBVL(4,1)+SBVL(2,2)
      IF(INDP.GT.0) THEN
        SMIN=SMIN+SBVL(1,17)
        SMPR=SMPR+SBVL(2,17)
      END IF
      IF(IMBF.EQ.1) THEN
C  RATIO MAY BE ADJUSTED
         IF((TIN/SMIN).LT.0.50) THEN
            DENOM=SMPR
            IMBF2=1
         ENDIF
      ENDIF
      IF(IMBF.EQ.2) THEN
C  RATIO MAY BE ADJUSTED
         IF((TOUT/SMIN).LT.0.50) THEN
            DENOM=SMPR
            IMBF2=1
         ENDIF
      ENDIF    
      IF((ICONLY.EQ.1).OR.((TIN.EQ.0.0).AND.(TOUT.EQ.0.0))) THEN
         DENOM=SMPR
         IMBF2=1
      ENDIF
cgzh mbprec use stored mass error calculation when precision concern with 
c    flux in/out
      IF(IPREC.EQ.1) THEN
         DENOM=SMPR
	   IMBF2=1
      END IF
  95  CONTINUE
cgzh debug (orig write statement)     WRITE(IOUTS,150) RESID
      WRITE(IOUTS,150) RESID
cgzh debug commented these 2 for training class and GW_Chart
c      WRITE(IOUTS,1150) RESID,SBVL(4,1),SBVL(4,2),TOUT,TIN
c 1150 FORMAT (//01X,'PART-BASED RESIDUAL  ',1PE15.7,
c     * ' SBVL(4,1) SBVL(4,2) TOUT TIN',4E16.7/)
C  PRINT OUT MASS BALANCE 
      IF(IMBF.EQ.1) WRITE (IOUTS,130) ERR
      IF(IMBF.EQ.2) WRITE (IOUTS,131) ERR
	IF(IMBF2.GT.0) THEN
         ERR2=(RESID*100.0)/DENOM
         WRITE(IOUTS,132) ERR2
	ENDIF 
cgzh mbprec
      IF(IPREC.EQ.1) THEN
        WRITE(IOUTS,*) '***NOTE*** THE CHANGE IN MASS STORED IS LESS
     * THAN 7 ORDERS OF MAGNITUDE SMALLER'
        WRITE(IOUTS,*) 'THAN THE MASS DISSOLVED.  THEREFORE, WITH
     * SINGLE-PRECISION, IT MAY NOT BE '
        WRITE(IOUTS,*) 'POSSIBLE TO ACCURATELY COMPUTE SOLUTE BUDGET
     * AND MASS BALANCE RESIDUAL NUMBERS.'
      END IF
cgzh ssfix
      GoTo 999
C     CUMULATIVE BUDGET NUMBERS FOR CASE OF MULTIPLE STEADY STRESS PERIODS
      IF(MULTSS.EQ.1) THEN
cgzh debug
C     FILL TEMPORARY CUMULATIVE ARRAY
        TEMPSBVL(1,3)=SBVL(5,3)+SBVL(3,3)
        TEMPSBVL(2,3)=SBVL(6,3)+SBVL(4,3)
        DO 8000 I=4,12
          TEMPSBVL(1,I)=SBVL(1,I)+SBVL(5,I)
          TEMPSBVL(2,I)=SBVL(4,I)+SBVL(6,I)
 8000  CONTINUE
        DO 8001 I=13,23
          TEMPSBVL(1,I)=SBVL(1,I)+SBVL(5,I)
          TEMPSBVL(2,I)=SBVL(2,I)+SBVL(6,I)
 8001  CONTINUE
        DO 8002 I=24,24
          TEMPSBVL(1,I)=SBVL(1,I)+SBVL(5,I)
          TEMPSBVL(2,I)=SBVL(4,I)+SBVL(6,I)
 8002  CONTINUE
        DO 8003 I=26,26
          TEMPSBVL(1,I)=SBVL(1,I)+SBVL(5,I)
          TEMPSBVL(2,I)=SBVL(2,I)+SBVL(6,I)
 8003  CONTINUE
        WRITE (IOUTS,9100) 
 9100   FORMAT (//1H ,2X,'***CUMULATIVE SOLUTE BUDGET FOR TRANSPORT SU
     *BGRID***')
        WRITE(IOUTS,*) '  (THESE VALUES NOT USED IN MASS BALANCE
     * CALCULATION)'
      IF(INDP.GT.0) WRITE (IOUTS,112) TEMPSBVL(1,18),TEMPSBVL(2,18)
cgzh old way      WRITE (IOUTS,115) (SBVL(1,L),L=3,12)
      WRITE (IOUTS,115)
      IF(DECAY.NE.0.) WRITE (IOUTS,503) TEMPSBVL(1,3)
      WRITE (IOUTS,504) TEMPSBVL(1,4)
      IF(ISUBGD.EQ.1) WRITE (IOUTS,505) TEMPSBVL(1,5)
      IF(IUNIT(8).GT.0) WRITE (IOUTS,506) TEMPSBVL(1,6)
      IF(IUNIT(2).GT.0) WRITE (IOUTS,507) TEMPSBVL(1,7)
      IF(IUNIT(4).GT.0) WRITE (IOUTS,508) TEMPSBVL(1,8)
      IF(IUNIT(3).GT.0) WRITE (IOUTS,509) TEMPSBVL(1,9)
      IF(IUNIT(7).GT.0) WRITE (IOUTS,510) TEMPSBVL(1,10)
      IF(IUNIT(5).GT.0) WRITE (IOUTS,511) TEMPSBVL(1,11)
      IF(IUNIT(16).GT.0) WRITE (IOUTS,512) TEMPSBVL(1,12)
cgzh
      IF(INSFRUNIT.GT.0) WRITE (IOUTS,133) TEMPSBVL(1,21)
      IF(INLAKUNIT.GT.0) WRITE (IOUTS,134) TEMPSBVL(1,22)
      IF(INDK.GT.0) THEN
        IF(IDKZO.EQ.1) WRITE (IOUTS,116) TEMPSBVL(1,13)
        IF(IDKFO.EQ.1) WRITE (IOUTS,117) TEMPSBVL(1,14)
        IF(IDKZS.EQ.1) WRITE (IOUTS,118) TEMPSBVL(1,15)
        IF(IDKFS.EQ.1) WRITE (IOUTS,119) TEMPSBVL(1,16)
      END IF
      IF(INAGE.GT.0) WRITE (IOUTS,120) TEMPSBVL(1,17)
      IF(INDP.GT.0) THEN
        IF(IDPZO.EQ.1) WRITE (IOUTS,121) TEMPSBVL(1,19)
        IF(IDPFO.EQ.1) WRITE (IOUTS,122) TEMPSBVL(1,20)
      END IF
      IF(INDRT.GT.0) WRITE (IOUTS,137) TEMPSBVL(1,23)
      IF(INMNW.GT.0) WRITE (IOUTS,140) TEMPSBVL(1,24)
      IF(INCCBD.GT.0) WRITE (IOUTS,141) TEMPSBVL(1,26)
CMOCWT
cgzh old way      WRITE (IOUTS,125) (SBVL(4,L),L=3,12)
      WRITE (IOUTS,125)
      IF(DECAY.NE.0.) WRITE (IOUTS,503) TEMPSBVL(2,3)
      WRITE (IOUTS,504) TEMPSBVL(2,4)
      IF(ISUBGD.EQ.1) WRITE (IOUTS,505) TEMPSBVL(2,5)
      IF(IUNIT(8).GT.0) WRITE (IOUTS,506) TEMPSBVL(2,6)
      IF(IUNIT(2).GT.0) WRITE (IOUTS,507) TEMPSBVL(2,7)
      IF(IUNIT(4).GT.0) WRITE (IOUTS,508) TEMPSBVL(2,8)
      IF(IUNIT(3).GT.0) WRITE (IOUTS,509) TEMPSBVL(2,9)
      IF(IUNIT(7).GT.0) WRITE (IOUTS,510) TEMPSBVL(2,10)
      IF(IUNIT(5).GT.0) WRITE (IOUTS,511) TEMPSBVL(2,11)
      IF(IUNIT(16).GT.0) WRITE (IOUTS,512) TEMPSBVL(2,12)
cgzh
      IF(INSFRUNIT.GT.0) WRITE (IOUTS,135) TEMPSBVL(2,21)
      IF(INLAKUNIT.GT.0) WRITE (IOUTS,136) TEMPSBVL(2,22)
      IF(INDK.GT.0) THEN
        IF(IDKZO.EQ.1) WRITE (IOUTS,116) TEMPSBVL(2,13)
        IF(IDKFO.EQ.1) WRITE (IOUTS,117) TEMPSBVL(2,14)
        IF(IDKZS.EQ.1) WRITE (IOUTS,118) TEMPSBVL(2,15)
        IF(IDKFS.EQ.1) WRITE (IOUTS,119) TEMPSBVL(2,16)
      END IF
      IF(INDP.GT.0) THEN
        IF(IDPZO.EQ.1) WRITE (IOUTS,121) TEMPSBVL(2,19)
        IF(IDPFO.EQ.1) WRITE (IOUTS,122) TEMPSBVL(2,20)
      END IF
      IF(INDRT.GT.0) WRITE (IOUTS,138) TEMPSBVL(2,23)
      IF(INMNW.GT.0) WRITE (IOUTS,140) TEMPSBVL(2,24)
      IF(INCCBD.GT.0) WRITE (IOUTS,141) TEMPSBVL(2,26)
      END IF
C
 999  Continue
 100  FORMAT (//1H ,10X,'SOLUTE BUDGET AND MASS BALANCE FOR TRANSPORT SU
     *BGRID'/)
 105  FORMAT (1H ,5X,'VALUES CALCULATED AT END OF: '/
     *15X,'STRESS PERIOD  ',I6,'  OUT OF ',I6/
     *14X,'FLOW TIME STEP  ',I6,'  OUT OF ',I6/
     *04X,'TRANSPORT TIME INCREMENT  ',I6,'  OUT OF ',I6/)
 107  FORMAT (1H ,5X,'ELAPSED TIME = ', 1PE11.4)
 110  FORMAT (/1H ,05X,'CHEMICAL MASS IN STORAGE: '/
     *10X,'INITIAL:   MASS DISSOLVED = ',1PE11.4,5X,
     *'MASS SORBED = ',1PE11.4/
     *10X,'PRESENT:   MASS DISSOLVED = ',1PE11.4,5X,
     *'MASS SORBED = ',1PE11.4)
 210  FORMAT (/1H ,10X,'PRESENT:   MASS DISSOLVED = ',1PE14.7,5X,
     *'FROM PARTICLES (after dsp applied)')
 310  FORMAT (1H ,10X,'PRESENT:   MASS DISSOLVED = ',1PE14.7,5X,
     *'FROM PARTICLES (before dsp applied)')
cgzh debug 
c orig lines
c 210  FORMAT (/1H ,10X,'PRESENT:   MASS DISSOLVED = ',1PE11.4,5X,
c     *'FROM PARTICLES (PTWT)')
c 310  FORMAT (1H ,10X,'PRESENT:   MASS DISSOLVED = ',1PE11.4,5X,
c     *'FROM PARTICLES (SUMC)')
 410  FORMAT (/1H ,10X,'PRESENT VOLUME:  = ',1PE13.7,5X,
     *'FROM PTWT')
 411  FORMAT (1H ,10X,'PRESENT VOLUME:  = ',1PE13.7,5X,
     *'FROM SUMWT')
 111  FORMAT (/
     *15X,'CHANGE IN MASS STORED = ',1PE11.4/)
 211  FORMAT (15X,'CHANGE IN MASS STORED = ',1PE11.4,
     *         5X,'BASED ON PARTICLES'//)
 112  FORMAT (
     *10X,'INITIAL:MASS DOUBLE POROS = ',1PE11.4/
     *10X,'PRESENT:MASS DOUBLE POROS = ',1PE11.4)
 115  FORMAT (//05X,'CUMULATIVE SOLUTE MASS  (L**3)(M/VOL)'/
     *          05X,'----------------------'//10X,'IN:'/10X,'---')
 503  FORMAT (
     *05X,'                DECAY = ',1PE11.4)
 504  FORMAT (
     *05X,'        CONSTANT HEAD = ',1PE11.4)
 505  FORMAT (
     *05X,'     SUBGRID BOUNDARY = ',1PE11.4)
 506  FORMAT (
     *05X,'             RECHARGE = ',1PE11.4)
 507  FORMAT (
     *05X,'                WELLS = ',1PE11.4)
 508  FORMAT (
     *05X,'               RIVERS = ',1PE11.4)
 509  FORMAT (
     *05X,'               DRAINS = ',1PE11.4)
 510  FORMAT (
     *05X,'GENL. HEAD-DEP. BDYS. = ',1PE11.4)
 511  FORMAT (
     *05X,'   EVAPOTRANSPIRATION = ',1PE11.4)
 512  FORMAT (
     *05X,' SPECIFIED FLOW (FHB) = ',1PE11.4)
 116  FORMAT (
     *05X,'    ZERO-ORDER GROWTH = ',1PE11.4)
 117  FORMAT (
     *05X,'    FIRST-ORDER DECAY = ',1PE11.4)
 118  FORMAT (
     *05X,'0-ORDER GROWTH SORBED = ',1PE11.4)
 119  FORMAT (
     *05X,' 1-ORDER DECAY SORBED = ',1PE11.4)
 120  FORMAT (
     *05X,'    AGE-MASS INCREASE = ',1PE11.4)
 121  FORMAT (
     *05X,' DP ZERO-ORDER GROWTH = ',1PE11.4)
 122  FORMAT (
     *05X,' DP FIRST-ORDER DECAY = ',1PE11.4)
 123  FORMAT (/
     *05X,'             TOTAL IN = ',1PE11.4/)
 125  FORMAT (/09X,'OUT:  '/09X,'----')
 126  FORMAT (/
     *05X,'TOTAL OUT:WEIGHTED PTS= ',1PE11.4/)
 139  FORMAT (/05X,'    SOURCE-TERM DECAY = ',1PE11.4/)
 130  FORMAT (05X,'  PERCENT DISCREPANCY = ',1PE11.4,
     *' RELATIVE TO MASS FLUX IN, BASED ON PTS.'/)
 131  FORMAT (05X,'  PERCENT DISCREPANCY = ',1PE11.4,
     *' RELATIVE TO MASS FLUX OUT, BASED ON PTS.'/)
 132  FORMAT (05X,'  PERCENT DISCREPANCY = ',1PE11.4,
     *' RELATIVE TO INITIAL MASS STORED, BASED ON PTS.'/)
 133  FORMAT (
     *05X,'LOSING STREAM REACHES = ',1PE11.4)
 134  FORMAT (
     *05X,'    LOSING LAKE CELLS = ',1PE11.4)
 135  FORMAT (
     *05X,' GAINING STREAM RCHS. = ',1PE11.4)
 136  FORMAT (
     *05X,'   GAINING LAKE CELLS = ',1PE11.4)
 137  FORMAT (
     *05X,' DRAIN RETURNS(DRT)   = ',1PE11.4)
 138  FORMAT (
     *05X,' DRAINS (DRT)         = ',1PE11.4)
 140  FORMAT (
     *05X,'     MULTI-NODE WELLS = ',1PE11.4)
 141  FORMAT (
     *05X,'   CONSTANT-CONC BDYS = ',1PE11.4)
 150  FORMAT (//03X,'PARTICLE-BASED RESIDUAL = ',1PE11.4/)
C  RELEASE MEMORY
      DEALLOCATE(TEMPSBVL)
      RETURN
      END
C
C
C
C
C  GWT1BAS6CV CALCULATE CELL VOLUME
C     ******************************************************************
C
      SUBROUTINE GWT1BAS6CV(CELVOL,THCK,POR,IBOUND,
     *  NSCOL,NSROW,NSLAY,NCOL,NROW,NLAY)
C
C     ******************************************************************
C
C    CALCULATE CELL VOLUME
C
C     ------------------------------------------------------------------
C
      DOUBLE PRECISION CELVOL
      DOUBLE PRECISION dt,dc,dr,dp
      DIMENSION IBOUND(NCOL,NROW,NLAY)
      DIMENSION THCK(NSCOL,NSROW,NSLAY),POR(NSCOL,NSROW,NSLAY),
     *  CELVOL(NSCOL,NSROW,NSLAY)
C
      COMMON /GWT/ CDEL,RDEL,CNOFLO,CELDIS,FZERO,NZCRIT
      COMMON /SUBGRD/
     *  ISCOL1,ISCOL2,ISROW1,ISROW2,ISLAY1,ISLAY2,ISUBGD
C
C     ------------------------------------------------------------------
      CELVOL=0.d0
      DO 10 KS=1,NSLAY
       K=KS+ISLAY1-1
      DO 10 IS=1,NSROW
       I=IS+ISROW1-1
      DO 10 JS=1,NSCOL
       J=JS+ISCOL1-1
C  SKIP NO-FLOW CELLS
       IF(IBOUND(J,I,K).EQ.0) GO TO 10
C  CALCULATE PORE VOLUME OF CELL (THCK*AREA*POROSITY)
       dt=dble(THCK(JS,IS,KS))
       dc=dble(CDEL)
       dr=dble(RDEL)
       dp=dble(POR(JS,IS,KS))
c	 CELVOL(JS,IS,KS)=THCK(JS,IS,KS)*CDEL*RDEL*POR(JS,IS,KS)
	 CELVOL(JS,IS,KS)=dt*dc*dr*dp
  10  CONTINUE
C
C9------RETURN
 1000 RETURN
      END
C
C     ******************************************************************
C
      SUBROUTINE PTWT1SRCF(ISRCID,SRCFAC,
     &  THCK,POR,RF,IGENPT,IBOUND,
     &  VC,VR,VL,
     &  NSCOL,NSROW,NSLAY,NCOL,NROW,NLAY,MAXSRC,
     &  RDEL,CDEL,TIMV,
cgzh srcfix2
     &  SS_SRC,SS_SNK,ISRCFIX,
     &  TOTFLUXIN,TOTFLUXOT,ICONTRIBIN,ICONTRIBOT)     
C
C DETERMINE CELL FOR NEW PARTICLE BY USING A PROBABILITY FUNCTION OVER THE
C OUTFLOW FACES OF THE STRONG SOURCE
C
C SRCFAC STORES INFO ON STRONG SOURCES FOR PARTICLE GENERATION WITH VOLUME FIX
C SRCFAC(MAXSRC,6,3)
C   MAXSRC = ID FOR STRONG SOURCE CELLS
C   6: values for each cell face
C   3rd spot: (1) = cumulative probability (0.0-1.0) normalized to total flux out
C   3rd spot: (2) = distance particle will move over 1/2 TIMV 
C                     due to flux across that face
C   3rd spot: (3) = cumulative probability (0.0-1.0) normalized to total flux in
C
C CALCULATE TOTFLOW IN and OUT FOR SS CELLS (FD METHOD)
C
      DOUBLE PRECISION TOTFLUXIN,TOTFLUXOT
      COMMON /SUBGRD/
     *  ISCOL1,ISCOL2,ISROW1,ISROW2,ISLAY1,ISLAY2,ISUBGD
      DIMENSION Q(6)
cgzh srcfix
      DIMENSION ISRCID(NSCOL,NSROW,NSLAY),SRCFAC(MAXSRC,6,3)
      DIMENSION IBOUND(NCOL,NROW,NLAY),
     *  VC(NSCOL+1,NSROW,NSLAY),VR(NSCOL,NSROW+1,NSLAY),
     *  VL(NSCOL,NSROW,NSLAY+1),
     *  RF(NSCOL,NSROW,NSLAY),THCK(NSCOL,NSROW,NSLAY),
     *  POR(NSCOL,NSROW,NSLAY),IGENPT(NSCOL,NSROW,NSLAY)
cgzh srcfix2
      DIMENSION SS_SRC(NSCOL,NSROW,NSLAY),SS_SNK(NSCOL,NSROW,NSLAY)
      DIMENSION TOTFLUXIN(NSCOL,NSROW,NSLAY),
     & TOTFLUXOT(NSCOL,NSROW,NSLAY),ICONTRIBIN(NSCOL,NSROW,NSLAY,6),
     & ICONTRIBOT(NSCOL,NSROW,NSLAY,6)
C
C Initialize 
      SRCFAC=0
      SS_SRC=0
	SS_SNK=0
      TOTFLUXIN=0.D0
      TOTFLUXOT=0.D0
      ICONTRIBIN=0
      ICONTRIBOT=0
C
      AREA=RDEL*CDEL
C
      DO 100 KS=1,NSLAY
      DO 100 IS=1,NSROW
      DO 100 JS=1,NSCOL
            J=JS+ISCOL1-1
            I=IS+ISROW1-1
            K=KS+ISLAY1-1
C  Reset Q and SUMQ for each cell
      Q=0
      SUMQ=0
cgzh debug
      if(js.eq.21.and.is.eq.1.and.ks.eq.1) then
	continue
	end if
C  ISRCID HAS LOCATIONS OF STRONG SOURCES
      IF(ISRCID(JS,IS,KS).GT.0) THEN
        ISRC=ISRCID(JS,IS,KS)
cgzh debug
      if(isrc.eq.8) then
	continue
	endif
C Check left column face
        IF(JS.GT.1) THEN
c	   IF(VC(JS,IS,KS).LT.0.0.AND.IGENPT(JS-1,IS,KS).EQ.0.AND
c     &     .IBOUND(J-1,I,K).NE.0) THEN
cgzh srcfix2 
	   IF(VC(JS,IS,KS).LT.0.0.AND.IBOUND(J-1,I,K).NE.0) THEN
          IF(IGENPT(JS-1,IS,KS).EQ.0) THEN

           Q(1)=ABS(VC(JS,IS,KS))
           SUMQ=SUMQ+Q(1)
C          This saves a distance to travel from this cell face = 1/2 
           SRCFAC(ISRC,1,2)=VC(JS,IS,KS)*TIMV*0.5/
     &	 (AREA*THCK(JS-1,IS,KS)*POR(JS-1,IS,KS)*rf(js-1,is,ks))
cgzh srcfix2
C if there is a positive flux out this face and into another strong source cell,
C save in SS_SNK and SS_SRC
          ELSE
           IF(ISRCFIX.GT.0) THEN
C VC is negative here 
            SS_SNK(JS,IS,KS)=SS_SNK(JS,IS,KS)+VC(JS,IS,KS)
            SS_SRC(JS-1,IS,KS)=SS_SRC(JS-1,IS,KS)-VC(JS,IS,KS)
	     END IF  
	    END IF  
	   END IF  
	  END IF  
C Check right column face
        IF(JS.LT.NSCOL) THEN
	   IF(VC(JS+1,IS,KS).GT.0.0.AND.IBOUND(J+1,I,K).NE.0) THEN
          IF(IGENPT(JS+1,IS,KS).EQ.0) THEN
           Q(2)=VC(JS+1,IS,KS)
           SUMQ=SUMQ+Q(2)
           SRCFAC(ISRC,2,2)=VC(JS+1,IS,KS)*TIMV*0.5/
     &	 (AREA*THCK(JS+1,IS,KS)*POR(JS+1,IS,KS)*rf(js+1,is,ks))
cgzh srcfix2
C save SS_SNK and SS_SRC
          ELSE
           IF(ISRCFIX.GT.0) THEN
C VC is positive here 
            SS_SNK(JS,IS,KS)=SS_SNK(JS,IS,KS)-VC(JS+1,IS,KS)
            SS_SRC(JS+1,IS,KS)=SS_SRC(JS+1,IS,KS)+VC(JS+1,IS,KS)
	     END IF  
	    END IF  
	   END IF  
	  END IF  
C Check upper row face
        IF(IS.GT.1) THEN
         IF(VR(JS,IS,KS).LT.0.0.AND.IBOUND(J,I-1,K).NE.0) THEN
          IF(IGENPT(JS,IS-1,KS).EQ.0) THEN
          Q(3)=ABS(VR(JS,IS,KS))
          SUMQ=SUMQ+Q(3)
          SRCFAC(ISRC,3,2)=VR(JS,IS,KS)*TIMV*0.5/
     &	(AREA*THCK(JS,IS-1,KS)*POR(JS,IS-1,KS)*rf(js,is-1,ks))
cgzh srcfix2
C save SS_SNK and SS_SRC
          ELSE
           IF(ISRCFIX.GT.0) THEN
            SS_SNK(JS,IS,KS)=SS_SNK(JS,IS,KS)+VR(JS,IS,KS)
            SS_SRC(JS,IS-1,KS)=SS_SRC(JS,IS-1,KS)-VR(JS,IS,KS)
	     END IF  
	    END IF  
	   END IF  
	  END IF  
C Check lower row face
        IF(IS.LT.NSROW) THEN
         IF(VR(JS,IS+1,KS).GT.0.0.AND.IBOUND(J,I+1,K).NE.0) THEN
          IF(IGENPT(JS,IS+1,KS).EQ.0) THEN
           Q(4)=VR(JS,IS+1,KS)
           SUMQ=SUMQ+Q(4)
           SRCFAC(ISRC,4,2)=VR(JS,IS+1,KS)*TIMV*0.5/
     &	 (AREA*THCK(JS,IS+1,KS)*POR(JS,IS+1,KS)*rf(JS,IS+1,ks))
cgzh srcfix2
C save SS_SNK and SS_SRC
          ELSE
           IF(ISRCFIX.GT.0) THEN
            SS_SNK(JS,IS,KS)=SS_SNK(JS,IS,KS)-VR(JS,IS+1,KS)
            SS_SRC(JS,IS+1,KS)=SS_SRC(JS,IS+1,KS)+VR(JS,IS+1,KS)
	     END IF  
		END IF  
	   END IF  
	  END IF  
C Check upper layer face
        IF(KS.GT.1) THEN
         IF(VL(JS,IS,KS).LT.0.0.AND.IBOUND(J,I,K-1).NE.0) THEN
	    IF(IGENPT(JS,IS,KS-1).EQ.0) THEN
           Q(5)=ABS(VL(JS,IS,KS))
           SUMQ=SUMQ+Q(5)
           SRCFAC(ISRC,5,2)=VL(JS,IS,KS)*TIMV*0.5/
     &	 (AREA*THCK(JS,IS,KS-1)*POR(JS,IS,KS-1)*rf(js,IS,KS-1))
cgzh srcfix2
C save SS_SNK and SS_SRC
          ELSE
           IF(ISRCFIX.GT.0) THEN
            SS_SNK(JS,IS,KS)=SS_SNK(JS,IS,KS)+VL(JS,IS,KS)
            SS_SRC(JS,IS,KS-1)=SS_SRC(JS,IS,KS-1)-VL(JS,IS,KS)
	     END IF  
	    END IF  
	   END IF  
	  END IF  
C Check lower layer face
        IF(KS.LT.NSLAY) THEN
         IF(VL(JS,IS,KS+1).GT.0.0.AND.IBOUND(J,I,K+1).NE.0) THEN
          IF(IGENPT(JS,IS,KS+1).EQ.0) THEN
           Q(6)=VL(JS,IS,KS+1)
           SUMQ=SUMQ+Q(6)
           SRCFAC(ISRC,6,2)=VL(JS,IS,KS+1)*TIMV*0.5/
     &	 (AREA*THCK(JS,IS,KS+1)*POR(JS,IS,KS+1)*rf(JS,IS,KS+1))
cgzh srcfix2
C save SS_SNK and SS_SRC
          ELSE
           IF(ISRCFIX.GT.0) THEN
            SS_SNK(JS,IS,KS)=SS_SNK(JS,IS,KS)-VL(JS,IS,KS+1)
            SS_SRC(JS,IS,KS+1)=SS_SRC(JS,IS,KS+1)+VL(JS,IS,KS+1)
	     END IF  
	    END IF  
	   END IF  
	  END IF  
C
      QTEMP=0.0
      DO 50 IFAC=1,6
        IF(Q(IFAC).GT.0) THEN
	    SRCFAC(ISRC,IFAC,1)=(Q(IFAC)+QTEMP)/SUMQ
          QTEMP=QTEMP+Q(IFAC)
c re-initialize for lower loop
          Q(IFAC)=0.0
        END IF
  50  CONTINUE
C
      SUMQ=0.0
C Calculate TOTFLUXIN and TOTFLUXOT 
C Check left column face for flow
      IF(ISRCFIX.GT.0) THEN
        IF(JS.GT.1) THEN
         IF(IGENPT(JS-1,IS,KS).EQ.0.AND.IBOUND(J-1,I,K).NE.0) THEN
	    IF(VC(JS,IS,KS).GT.0.0) THEN
C VC is positive  here for flow into js,is,ks
            TOTFLUXIN(JS,IS,KS)=TOTFLUXIN(JS,IS,KS)+VC(JS,IS,KS)*TIMV
            ICONTRIBIN(JS-1,IS,KS,1)=1
            Q(1)=ABS(VC(JS,IS,KS))
            SUMQ=SUMQ+Q(1)
	    END IF  
C
	    IF(VC(JS,IS,KS).LT.0.0) THEN
C VC is negative  here for flow out of js,is,ks
            TOTFLUXOT(JS,IS,KS)=TOTFLUXOT(JS,IS,KS)-VC(JS,IS,KS)*TIMV
            ICONTRIBOT(JS-1,IS,KS,1)=1
	    END IF  
	   END IF  
	  END IF  
C Check right column face
        IF(JS.LT.NSCOL) THEN
         IF(IGENPT(JS+1,IS,KS).EQ.0.AND.IBOUND(J+1,I,K).NE.0) THEN
	    IF(VC(JS+1,IS,KS).LT.0.0) THEN
C VC is negative here for flow into js,is,ks
            TOTFLUXIN(JS,IS,KS)=TOTFLUXIN(JS,IS,KS)-VC(JS+1,IS,KS)*TIMV
            ICONTRIBIN(JS+1,IS,KS,2)=1
            Q(2)=ABS(VC(JS+1,IS,KS))
            SUMQ=SUMQ+Q(2)
	    END IF  
C
	    IF(VC(JS+1,IS,KS).GT.0.0) THEN
C VC is positive here for flow out of js,is,ks
            TOTFLUXOT(JS,IS,KS)=TOTFLUXOT(JS,IS,KS)+VC(JS+1,IS,KS)*TIMV
            ICONTRIBOT(JS+1,IS,KS,2)=1
	    END IF  
	   END IF  
	  END IF  
C Check upper row face
        IF(IS.GT.1) THEN
         IF(IGENPT(JS,IS-1,KS).EQ.0.AND.IBOUND(J,I-1,K).NE.0) THEN
          IF(VR(JS,IS,KS).GT.0.0) THEN
            TOTFLUXIN(JS,IS,KS)=TOTFLUXIN(JS,IS,KS)+VR(JS,IS,KS)*TIMV
            ICONTRIBIN(JS,IS-1,KS,3)=1
            Q(3)=ABS(VR(JS,IS,KS))
            SUMQ=SUMQ+Q(3)
	    END IF  
          IF(VR(JS,IS,KS).LT.0.0) THEN
            TOTFLUXOT(JS,IS,KS)=TOTFLUXOT(JS,IS,KS)-VR(JS,IS,KS)*TIMV
            ICONTRIBOT(JS,IS-1,KS,3)=1
	    END IF  
	   END IF  
	  END IF  
C Check lower row face
        IF(IS.LT.NSROW) THEN
         IF(IGENPT(JS,IS+1,KS).EQ.0.AND.IBOUND(J,I+1,K).NE.0) THEN
          IF(VR(JS,IS+1,KS).LT.0.0) THEN
            TOTFLUXIN(JS,IS,KS)=TOTFLUXIN(JS,IS,KS)-VR(JS,IS+1,KS)*TIMV
            ICONTRIBIN(JS,IS+1,KS,4)=1
            Q(4)=ABS(VR(JS,IS+1,KS))
            SUMQ=SUMQ+Q(4)
		END IF  
          IF(VR(JS,IS+1,KS).GT.0.0) THEN
            TOTFLUXOT(JS,IS,KS)=TOTFLUXOT(JS,IS,KS)+VR(JS,IS+1,KS)*TIMV
            ICONTRIBOT(JS,IS+1,KS,4)=1
		END IF  
	   END IF  
	  END IF  
C Check upper layer face
        IF(KS.GT.1) THEN
	   IF(IGENPT(JS,IS,KS-1).EQ.0.AND.IBOUND(J,I,K-1).NE.0) THEN
          IF(VL(JS,IS,KS).GT.0.0) THEN
            TOTFLUXIN(JS,IS,KS)=TOTFLUXIN(JS,IS,KS)+VL(JS,IS,KS)*TIMV
            ICONTRIBIN(JS,IS,KS-1,5)=1
            Q(5)=ABS(VL(JS,IS,KS))
            SUMQ=SUMQ+Q(5)
	    END IF  
          IF(VL(JS,IS,KS).LT.0.0) THEN
            TOTFLUXOT(JS,IS,KS)=TOTFLUXOT(JS,IS,KS)-VL(JS,IS,KS)*TIMV
            ICONTRIBOT(JS,IS,KS-1,5)=1
	    END IF  
	   END IF  
	  END IF  
C Check lower layer face
        IF(KS.LT.NSLAY) THEN
         IF(IGENPT(JS,IS,KS+1).EQ.0.AND.IBOUND(J,I,K+1).NE.0) THEN
          IF(VL(JS,IS,KS+1).LT.0.0) THEN
            TOTFLUXIN(JS,IS,KS)=TOTFLUXIN(JS,IS,KS)-VL(JS,IS,KS+1)*TIMV
            ICONTRIBIN(JS,IS,KS+1,6)=1
            Q(6)=ABS(VL(JS,IS,KS+1))
            SUMQ=SUMQ+Q(6)
	    END IF  
          IF(VL(JS,IS,KS+1).GT.0.0) THEN
            TOTFLUXOT(JS,IS,KS)=TOTFLUXOT(JS,IS,KS)+VL(JS,IS,KS+1)*TIMV
            ICONTRIBOT(JS,IS,KS+1,6)=1
	    END IF  
	   END IF  
	  END IF       
      QTEMP=0.0
      DO 60 IFAC=1,6
        IF(Q(IFAC).GT.0) THEN
	    SRCFAC(ISRC,IFAC,3)=(Q(IFAC)+QTEMP)/SUMQ
          QTEMP=QTEMP+Q(IFAC)
        END IF
C
  60  CONTINUE
c isrcid>0
	END IF  
c srcfix>0 end
      ENDIF
 100  CONTINUE
C
      RETURN
C
      END
C
C
C
C     ******************************************************************
C
      SUBROUTINE PTWT1REWET(IBOUND,IBOUNC,
     *              PC,PR,PL,PCONC,IPTID,
     *              PNEWC,PNEWR,PNEWL,NEWPTS,
     *              PCORIG,PRORIG,PLORIG,
     *              NPTCOLA,NPTROWA,NPTLAYA,IDIM,
     *              NPCELL,CELVOL,PTWT,SUMWT,
     *              WETDRY,SUMMASS,VC,VR,VL,CONC,
     *              INIPDL,INIPDA,WTFAC,
     *              NCOL,NROW,NLAY,NSCOL,NSROW,NSLAY,NPMAX,NP,IOUTS)
C TEMPORARY ARRAYS
cgzh debug double ptwt, sumwt
      DOUBLE PRECISION CELVOL
      DOUBLE PRECISION PTWT,SUMWT,VOL,SUMMASS,TEMPWT,TEMPMS
      DOUBLE PRECISION REWETMASS,CONTRIBVOL,CONTRIBMASS
      DOUBLE PRECISION SUMM,FLUXKP,FLUXRM,FLUXRP,FLUXCM,FLUXCP,TEMMASS
      REAL L
      ALLOCATABLE REMPCT(:,:,:),IREWET(:,:,:),
     *  TEMPWT(:,:,:),TEMPMS(:,:,:)
      DIMENSION
     *  IBOUND(NCOL,NROW,NLAY),IBOUNC(NCOL,NROW,NLAY),
     *  PC(NPMAX),PR(NPMAX),PL(NPMAX),PCONC(NPMAX),IPTID(NPMAX),
     *  NPCELL(NSCOL,NSROW,NSLAY),WTFAC(NSCOL,NSROW,NSLAY),
     *  PNEWC(NEWPTS),PNEWR(NEWPTS),PNEWL(NEWPTS),
     *  SUMWT(NSCOL,NSROW,NSLAY),VOLOLD(NSROW,NSCOL,NSLAY),
     *  PTWT(NPMAX),DELVOL(NSCOL,NSROW,NSLAY),CELVOL(NSCOL,NSROW,NSLAY),
     *  SUMMASS(NSCOL,NSROW,NSLAY),WETDRY(NCOL,NROW,NLAY),
     *  CONC(NSCOL,NSROW,NSLAY),
     *  VC(NSCOL+1,NSROW,NSLAY),VR(NSCOL,NSROW+1,NSLAY),
     *  VL(NSCOL,NSROW,NSLAY+1)
cgzh varpt
      DIMENSION PCORIG(NPMAX),PRORIG(NPMAX),PLORIG(NPMAX),
     *  NPTCOLA(NSCOL,NSROW,NSLAY),NPTROWA(NSCOL,NSROW,NSLAY),
     *  NPTLAYA(NSCOL,NSROW,NSLAY)
C
      COMMON /SUBGRD/
     *  ISCOL1,ISCOL2,ISROW1,ISROW2,ISLAY1,ISLAY2,ISUBGD
C
C     ****************************************************************
      ALLOCATE(REMPCT(NSCOL,NSROW,NSLAY),IREWET(NSCOL,NSROW,NSLAY))
      ALLOCATE(TEMPWT(NSCOL,NSROW,NSLAY),TEMPMS(NSCOL,NSROW,NSLAY))
C
C POPULATE REWETTED CELLS WITH PARTICLES
C
      TEMPWT=0.0
	TEMPMS=0.0
	REMPCT=0.0
      IREWET=0
C  LOOP OVER CELLS, DEFINE WETTED CELLS
C  THIS LIMITS HOW MUCH MASS CAN MOVE IN FROM CONTRIBUTING CELLS
      FRAC_CONTRIB=0.5
C
      DO 10 KS=1,NSLAY
       K=KS+ISLAY1-1
      DO 10 IS=1,NSROW
       I=IS+ISROW1-1
      DO 10 JS=1,NSCOL
       J=JS+ISCOL1-1
      IF(IBOUND(J,I,K).GT.0.AND.IBOUNC(J,I,K).EQ.0) THEN
        IREWET(JS,IS,KS)=1
      END IF
   10 CONTINUE
C
C  LOOP OVER CELLS, ADD PARTICLES TO REWETTED CELLS
      DO 100 KS=1,NSLAY
      DO 100 IS=1,NSROW
      DO 100 JS=1,NSCOL
      IF(IREWET(JS,IS,KS).EQ.1) THEN
       VOL=CELVOL(JS,IS,KS)
cgzh debug output
c      write(iouts,*) 'Rewetted cell at js,is,ks,vol',js,is,ks
c      write(iouts,*) 'Rewetted vol',vol
       TEMC=0.0
       REWETMASS=0.0
C  CASE: WETDRY<0, only use cell below to rewet
       IF(WETDRY(JS,IS,KS).LT.0) THEN
C  Only calc conc of new weight if:
C    cell below is active part of subgrid
C    cell below has particles with mass
	  IF(KS.LT.NSLAY) THEN      
         IF(SUMMASS(JS,IS,KS+1).GT.0.0) THEN
C  Calculate mass that should be added to rewetted cell
          REWETMASS=CONC(JS,IS,KS+1)*VOL
cgzh debug output
c      write(iouts,*) 'wd<1,rewetmass1,conc',REWETMASS,conc(js,is,ks+1)
C  Restrict mass added if it exceeds ratio of the mass in the contributing cell
          IF(REWETMASS.GT.(SUMMASS(JS,IS,KS+1)*FRAC_CONTRIB))
     *     REWETMASS=(SUMMASS(JS,IS,KS+1)*FRAC_CONTRIB)
C  C' at rewet cell= mass being added (possibly restricted) divided by weight added
          TEMC=REWETMASS/VOL
cgzh debug output
c      write(iouts,*) 'wd<1,rewetmass2,temc',REWETMASS,temc
C  Track how much mass must be removed from pts in contributing cell as percentage
C RBW potential bug: If the cell at JS,IS,KS+1 also causes a lateral cell to rewet
C REMPCT may be set incorrectly here.
          REMPCT(JS,IS,KS+1)=REWETMASS/SUMMASS(JS,IS,KS+1)
cgzh debug output
c      write(iouts,*) 'wd<1,rempct',REMPCT(JS,IS,KS+1)
         END IF
        END IF
C  CASE: WETDRY>0, use lateral cells and cell below to rewet
       ELSEIF(WETDRY(JS,IS,KS).GT.0) THEN
c stores total mass and vol flux of contributing cells for C' calc
        SUMM=0.0
        SUMF=0.0
C these store mass fluxes at,e.g., K+1 (KP), R-1 (RM) etc.
        FLUXKP=0.0
        FLUXRM=0.0
        FLUXRP=0.0
        FLUXCM=0.0
        FLUXCP=0.0
C  Only use cells as mass contributors if:
C    cell is active part of subgrid
C    positive influx from cell to rewetted cell
C    cell has not just been rewetted (impossible for K+1 case)
C    cell has particles with mass (not needed for C' calc)
C
C  For cell below (lay)
	  IF(KS.LT.NSLAY) THEN      
         IF(VL(JS,IS,KS+1).LT.0) THEN
C  Sum mass and vol flux of contributing cell to determine C' 
          SUMF=SUMF+ABS(VL(JS,IS,KS+1))
C  If this cell will contribute mass, track the flux use as weight
          IF(SUMMASS(JS,IS,KS+1).GT.0.0) THEN
            FLUXKP=ABS(VL(JS,IS,KS+1)*CONC(JS,IS,KS+1))
            SUMM=SUMM+FLUXKP
          END IF
	   END IF
        END IF
C  For cell to left (row)
	  IF(IS.GT.ISROW1) THEN      
         IF(VR(JS,IS,KS).GT.0.AND.IREWET(JS,IS-1,K).EQ.0) THEN
C  Sum mass and vol flux of contributing cell to determine C' 
          SUMF=SUMF+ABS(VR(JS,IS,KS))
C  If this cell will contribute mass, track the flux use as weight
          IF(SUMMASS(JS,IS-1,KS).GT.0.0) THEN
            FLUXRM=ABS(VR(JS,IS,KS)*CONC(JS,IS-1,KS))            
            SUMM=SUMM+FLUXRM
          END IF
	   END IF
        END IF
C  For cell to right (row)
	  IF(IS.LT.ISROW2) THEN      
         IF(VR(JS,IS+1,KS).LT.0.AND.IREWET(JS,IS+1,K).EQ.0) THEN
C  Sum mass and vol flux of contributing cell to determine C' 
          SUMF=SUMF+ABS(VR(JS,IS+1,KS))
C  If this cell will contribute mass, track the flux use as weight
          IF(SUMMASS(JS,IS+1,KS).GT.0.0) THEN
            FLUXRP=ABS(VR(JS,IS+1,KS)*CONC(JS,IS+1,KS))            
            SUMM=SUMM+FLUXRP
          END IF
	   END IF
        END IF
C  For cell above (col)
	  IF(JS.GT.ISCOL1) THEN      
         IF(VC(JS,IS,KS).GT.0.AND.IREWET(JS-1,IS,K).EQ.0) THEN
C  Sum mass and vol flux of contributing cell to determine C' 
          SUMF=SUMF+ABS(VC(JS,IS,KS))
C  If this cell will contribute mass, track the flux use as weight
          IF(SUMMASS(JS-1,IS,KS).GT.0.0) THEN
            FLUXCM=ABS(VC(JS,IS,KS)*CONC(JS-1,IS,KS))            
            SUMM=SUMM+FLUXCM
          END IF
	   END IF
        END IF
C  For cell below (col)
	  IF(JS.LT.ISCOL2) THEN      
         IF(VC(JS+1,IS,KS).LT.0.AND.IREWET(JS+1,IS,K).EQ.0) THEN
C  Sum mass and vol flux of contributing cell to determine C' 
          SUMF=SUMF+ABS(VC(JS+1,IS,KS))
C  If this cell will contribute mass, track the flux use as weight
          IF(SUMMASS(JS+1,IS,KS).GT.0.0) THEN
            FLUXCP=ABS(VC(JS+1,IS,KS)*CONC(JS+1,IS,KS))            
            SUMM=SUMM+FLUXCP
          END IF
	   END IF
        END IF
C
C  Calculate C for rewetted cell (pre-restrictions)
        IF(SUMF.GT.0) THEN
          TEMC=SUMM/SUMF
        END IF
C  Calculate unrestricted new mass in rewetted cell
	  REWETMASS=TEMC*VOL
C  Initialize amount this will be reduced by restrictions below
        REDUCEMASS=0.0
cgzh debug output
c      write(iouts,*) 'wd>1,kp,rm,rp,cm,cp',
c     * fluxkp,fluxrm,fluxrp,fluxcm,fluxcp
c      write(iouts,*) 'wd>1,summ,sumf,temc',
c     * summ,sumf,temc
c      write(iouts,*) 'wd>1,rewetmass1',rewetmass
C  Check available mass in contributing cell versus the proportion of mass
C    those cells provide, based on cell's mass influx/total mass influx,
C    restrict this mass if necessary
C  When checking available mass, account for mass already used as a contributor
C    elsewhere by subtracting out the percentage calculated last time this
C    cell was used (REMPCT)...this starts off at 0.0 so if cell only
C    contributes once, this amounts to mult by 1.0 
C  For cell below (lay)
	  IF(FLUXKP.GT.0) THEN
           FLUXPCT=FLUXKP/SUMM           
           TEMMASS=FLUXPCT*REWETMASS
           AVAILMASS=(SUMMASS(JS,IS,KS+1)*(1.0-REMPCT(JS,IS,KS+1)))
cgzh debug output
c      if(rempct(js,is,ks+1).ne.0.0) write(iouts,*)
c     & 'Contributing cell mass percentage accounted for already:',
c     &  REMPCT(JS,IS,KS+1)
           IF(TEMMASS.GT.(AVAILMASS*FRAC_CONTRIB))
     &       REDUCEMASS=REDUCEMASS+
     &        AVAILMASS*FRAC_CONTRIB
cgzh debug output
c      write(iouts,*) 'wd>1,kp,temmass,1/2 availmass',
c     * TEMMASS,AVAILMASS*FRAC_CONTRIB
        END IF
C  For cell to left (row)
	  IF(FLUXRM.GT.0) THEN
           FLUXPCT=FLUXRM/SUMM           
           TEMMASS=FLUXPCT*REWETMASS
           AVAILMASS=(SUMMASS(JS,IS-1,KS)*(1.0-REMPCT(JS,IS-1,KS)))
cgzh debug output
c      if(rempct(js,is-1,ks).ne.0.0) write(iouts,*)
c     & 'Contributing cell mass percentage accounted for already:',
c     &  REMPCT(JS,IS-1,KS)
           IF(TEMMASS.GT.(AVAILMASS*FRAC_CONTRIB))
     &       REDUCEMASS=REDUCEMASS+
     &        AVAILMASS*FRAC_CONTRIB
cgzh debug output
c      write(iouts,*) 'wd>1,rm,temmass,1/2 availmass',
c     * TEMMASS,AVAILMASS*FRAC_CONTRIB
        END IF
C  For cell to right (row)
	  IF(FLUXRP.GT.0) THEN
           FLUXPCT=FLUXRP/SUMM           
           TEMMASS=FLUXPCT*REWETMASS
           AVAILMASS=(SUMMASS(JS,IS+1,KS)*(1.0-REMPCT(JS,IS+1,KS)))
cgzh debug output
c      if(rempct(js,IS+1,KS).ne.0.0) write(iouts,*)
c     & 'Contributing cell mass percentage accounted for already:',
c     &  REMPCT(JS,IS+1,KS)
           IF(TEMMASS.GT.(AVAILMASS*FRAC_CONTRIB))
     &       REDUCEMASS=REDUCEMASS+
     &        AVAILMASS*FRAC_CONTRIB
cgzh debug output
c      write(iouts,*) 'wd>1,rp,temmass,1/2 availmass',
c     * TEMMASS,AVAILMASS*FRAC_CONTRIB
        END IF
C  For cell above (col)
	  IF(FLUXCM.GT.0) THEN
           FLUXPCT=FLUXCM/SUMM           
           TEMMASS=FLUXPCT*REWETMASS
           AVAILMASS=(SUMMASS(JS-1,IS,KS)*(1.0-REMPCT(JS-1,IS,KS)))
cgzh debug output
c      if(rempct(JS-1,IS,KS).ne.0.0) write(iouts,*)
c     & 'Contributing cell mass percentage accounted for already:',
c     &  REMPCT(JS-1,IS,KS)
           IF(TEMMASS.GT.(AVAILMASS*FRAC_CONTRIB))
     &       REDUCEMASS=REDUCEMASS+
     &        AVAILMASS*FRAC_CONTRIB
cgzh debug output
c      write(iouts,*) 'wd>1,cm,temmass,1/2 availmass',
c     * TEMMASS,AVAILMASS*FRAC_CONTRIB
        END IF
C  For cell below (col)
	  IF(FLUXCP.GT.0) THEN
           FLUXPCT=FLUXCP/SUMM           
           TEMMASS=FLUXPCT*REWETMASS
           AVAILMASS=(SUMMASS(JS+1,IS,KS)*(1.0-REMPCT(JS+1,IS,KS)))
cgzh debug output
c      if(rempct(JS+1,IS,KS).ne.0.0) write(iouts,*)
c     & 'Contributing cell mass percentage accounted for already:',
c     &  REMPCT(JS+1,IS,KS)
           IF(TEMMASS.GT.(AVAILMASS*FRAC_CONTRIB))
     &       REDUCEMASS=REDUCEMASS+
     &        AVAILMASS*FRAC_CONTRIB
cgzh debug output
c      write(iouts,*) 'wd>1,cp,temmass,1/2 availmass',
c     * TEMMASS,AVAILMASS*FRAC_CONTRIB
        END IF
C  Apply reduction to REWETMASS
          REWETMASS=REWETMASS-REDUCEMASS

C  C' at rewet cell= mass being added (possibly restricted) divided by weight added
          TEMC=REWETMASS/VOL
cgzh debug output
c      write(iouts,*) 'wd>1,rewetmass2,temc',
c     * rewetmass,temc

C  Track how much mass must be removed from pts in contributing cells as percentage
C  percentage of mass removed = mass removed at rewet cell (adjusted) * mass flux-based
C    ratio, divided by mass in contrib cell
C RBW potential bug: If a source cell causes two or more cells to rewet
C REMPCT may be set incorrectly here.
          IF(FLUXKP.GT.0.) 
     * REMPCT(JS,IS,KS+1)=(REWETMASS*(FLUXKP/SUMM))/SUMMASS(JS,IS,KS+1)
          IF(FLUXRM.GT.0.) 
     * REMPCT(JS,IS-1,KS)=(REWETMASS*(FLUXRM/SUMM))/SUMMASS(JS,IS-1,KS)
          IF(FLUXRP.GT.0.) 
     * REMPCT(JS,IS+1,KS)=(REWETMASS*(FLUXRP/SUMM))/SUMMASS(JS,IS+1,KS)
          IF(FLUXCM.GT.0.) 
     * REMPCT(JS-1,IS,KS)=(REWETMASS*(FLUXCM/SUMM))/SUMMASS(JS-1,IS,KS)
          IF(FLUXCP.GT.0.) 
     * REMPCT(JS+1,IS,KS)=(REWETMASS*(FLUXCP/SUMM))/SUMMASS(JS+1,IS,KS)
C  endif wetdry
	 END IF
cgzh varpt 
            IF(INIPDL.EQ.0.AND.INIPDA.EQ.0) THEN
cgzh debug
c            WRITE(IOUTS,*) 
c            WRITE(IOUTS,*)'Calling ADDPTS: PTWT1REWET.'
c            WRITE(IOUTS,*) 'Creating',NEWPTS-1,' new particles in ',
c     *                     'rewetted cell at (js,is,ks):'
c            WRITE(IOUTS,*) js,is,ks
              CALL ADDPTS(PC,PR,PL,PCONC,TEMC,IPTID,NPCELL,
     *          IBOUND,PNEWC,PNEWR,PNEWL,
     *          PTWT,VOL,
     *          NCOL,NROW,NLAY,NSCOL,NSROW,NSLAY,
     *          NEWPTS,NPMAX,
     *          JS,IS,KS,
     *          IOUTS,NP,WTFAC)
            ELSE
cgzh varpt 
cgzh get particle distribution for this cell
              NPTCOL=NPTCOLA(JS,IS,KS)
              NPTROW=NPTROWA(JS,IS,KS)
              NPTLAY=NPTLAYA(JS,IS,KS)
cgzh debug
            WRITE(IOUTS,*) 
	npte=NPTCOL*NPTROW*NPTLAY
c            WRITE(IOUTS,*)'Calling ADDPTSVAR: PTWT1REWET.'
c            WRITE(IOUTS,*) 'Creating',npte,' new particles in ',
c     *                     'rewetted cell at (js,is,ks):'
c            WRITE(IOUTS,*) js,is,ks
             CALL ADDPTSVAR(PC,PR,PL,PCONC,TEMC,
     *          NPCELL,PCORIG,PRORIG,PLORIG,
     *          PTWT,VOL,
     *          NSCOL,NSROW,NSLAY,
     *          NPMAX,NPTCOL,NPTROW,NPTLAY,
     *          JS,IS,KS,
     *          IOUTS,NPTM,IDIM,WTFAC)
            END IF
C  ADD WEIGHTS AND MASS ALTERED TO "SUM" ARRAYS
        SUMWT(JS,IS,KS)=SUMWT(JS,IS,KS)+VOL
        SUMMASS(JS,IS,KS)=SUMMASS(JS,IS,KS)+VOL*TEMC
C  endif irewet=1
      END IF
C  
  100	CONTINUE
C 
C 
C LOOP OVER PARTICLES TO ADJUST WEIGHTS IN CONTRIBUTING CELLS
      DO 200 IP=1,NP
      IF(PC(IP).EQ.0.0) GO TO 200
      J=PC(IP)+0.5
      JS=J-ISCOL1+1
      I=ABS(PR(IP))+0.5
      IS=I-ISROW1+1
      K=PL(IP)+0.5
      KS=K-ISLAY1+1
C
      IF(IBOUND(J,I,K).NE.0) THEN
        IF(REMPCT(JS,IS,KS).GT.0.) THEN
	    REMWT=PTWT(IP)*REMPCT(JS,IS,KS)
          PTWT(IP)=PTWT(IP)-REMWT
          TEMPWT(JS,IS,KS)=TEMPWT(JS,IS,KS)-REMWT
          TEMPMS(JS,IS,KS)=TEMPMS(JS,IS,KS)-REMWT*PCONC(IP)
	  END IF  
      END IF
 200  CONTINUE
C
C  ADD WEIGHTS AND MASS ALTERED TO "SUM" ARRAYS
      DO 300 KS=1,NSLAY
      DO 300 IS=1,NSROW
      DO 300 JS=1,NSCOL
        SUMWT(JS,IS,KS)=SUMWT(JS,IS,KS)+TEMPWT(JS,IS,KS)
        SUMMASS(JS,IS,KS)=SUMMASS(JS,IS,KS)+TEMPMS(JS,IS,KS)
cgzh debug output
c      if (tempms(js,is,ks).lt.0.) then
c      write(iouts,*) 'Mass removed from js,is,ks',js,is,ks
c      write(iouts,*) 'Mass, weight removed',tempms(js,is,ks),
c     * tempwt(js,is,ks)
c      end if
 300  CONTINUE
C

C  RELEASE MEMORY
      DEALLOCATE(REMPCT,IREWET,TEMPWT,TEMPMS)
C     ****************************************************************
      RETURN
C     ****************************************************************
      END
C
C
C     ******************************************************************
C
      SUBROUTINE PTWT1SSFL(ISRCID,
     &  IGENPT,IBOUND,
     &  VC,VR,VL,
     &  NSCOL,NSROW,NSLAY,NCOL,NROW,NLAY,
     &  RDEL,CDEL,TIMV,
     &  SRCSOL,SRCVOL,SRCDCY,CONC,
     *  DKFO,DKFS,INDK,IDKFO,IDKFS,DECAY,
     &  SS_SRC,SS_SNK,SS_SOL,ISRCFIX,imov)     
C
C  SAVE SS_SOL FOR RE-CALCULATION OF SRCAVC 
C
      COMMON /SUBGRD/
     *  ISCOL1,ISCOL2,ISROW1,ISROW2,ISLAY1,ISLAY2,ISUBGD
      DIMENSION Q(6)
      DOUBLE PRECISION DECAY
      DOUBLE PRECISION DCYFCT,DCYT,DCYT2
C
      DIMENSION DKFO(NSCOL,NSROW,NSLAY),
     *    DKFS(NSCOL,NSROW,NSLAY)
cgzh srcfix
      DIMENSION ISRCID(NSCOL,NSROW,NSLAY)
      DIMENSION IBOUND(NCOL,NROW,NLAY),
     *  VC(NSCOL+1,NSROW,NSLAY),VR(NSCOL,NSROW+1,NSLAY),
     *  VL(NSCOL,NSROW,NSLAY+1),
     *  IGENPT(NSCOL,NSROW,NSLAY),CONC(NSCOL,NSROW,NSLAY)
cgzh srcfix2
      DIMENSION SS_SRC(NSCOL,NSROW,NSLAY),SS_SNK(NSCOL,NSROW,NSLAY),
     *  SS_SOL(NSCOL,NSROW,NSLAY)
      DIMENSION SRCSOL(NSCOL,NSROW,NSLAY),SRCVOL(NSCOL,NSROW,NSLAY)
C
C Initialize 
	SS_SOL=0
C
      DO 100 KS=1,NSLAY
      DO 100 IS=1,NSROW
      DO 100 JS=1,NSCOL
            J=JS+ISCOL1-1
            I=IS+ISROW1-1
            K=KS+ISLAY1-1
cgzh debug
      if(js.eq.62) then
	continue
	endif
C  ISRCID HAS LOCATIONS OF STRONG SOURCES
      IF(ISRCID(JS,IS,KS).GT.0) THEN
C Check left column face for ss-to-ss flow
        IF(JS.GT.1) THEN
	   IF(VC(JS,IS,KS).LT.0.0.AND.IBOUND(J-1,I,K).NE.0) THEN
          IF(IGENPT(JS-1,IS,KS).GT.0) THEN
C VC is negative here for flow out of js,is,ks
            SS_SOL(JS-1,IS,KS)=SS_SOL(JS-1,IS,KS)
     & -VC(JS,IS,KS)*CONC(JS,IS,KS)
	    END IF  
	   END IF  
	  END IF  
C Check left column face for subgrid outflow
cgzh no need to add this here, it is already handled in BDYSNK
cgzh pt will be removed, and re-distributed, and then BDYSNK will be applied...
c        IF(JS.EQ.1) THEN
c	   IF(VC(JS,IS,KS).LT.0.0) THEN
c            SS_SNK(JS,IS,KS)=SS_SNK(JS,IS,KS)+VC(JS,IS,KS)
c	   END IF  
c	  END IF  
C Check right column face
        IF(JS.LT.NSCOL) THEN
	   IF(VC(JS+1,IS,KS).GT.0.0.AND.IBOUND(J+1,I,K).NE.0) THEN
          IF(IGENPT(JS+1,IS,KS).GT.0) THEN
C VC is positive here for flow out of js,is,ks
            SS_SOL(JS+1,IS,KS)=SS_SOL(JS+1,IS,KS)+
     & VC(JS+1,IS,KS)*CONC(JS,IS,KS)
	    END IF  
	   END IF  
	  END IF  
C Check upper row face
        IF(IS.GT.1) THEN
         IF(VR(JS,IS,KS).LT.0.0.AND.IBOUND(J,I-1,K).NE.0) THEN
          IF(IGENPT(JS,IS-1,KS).GT.0) THEN
            SS_SOL(JS,IS-1,KS)=SS_SOL(JS,IS-1,KS)
     & -VR(JS,IS,KS)*CONC(JS,IS,KS)
	    END IF  
	   END IF  
	  END IF  
C Check lower row face
        IF(IS.LT.NSROW) THEN
         IF(VR(JS,IS+1,KS).GT.0.0.AND.IBOUND(J,I+1,K).NE.0) THEN
          IF(IGENPT(JS,IS+1,KS).GT.0) THEN
            SS_SOL(JS,IS+1,KS)=SS_SOL(JS,IS+1,KS)+
     & VR(JS,IS+1,KS)*CONC(JS,IS,KS)
		END IF  
	   END IF  
	  END IF  
C Check upper layer face
        IF(KS.GT.1) THEN
         IF(VL(JS,IS,KS).LT.0.0.AND.IBOUND(J,I,K-1).NE.0) THEN
	    IF(IGENPT(JS,IS,KS-1).GT.0) THEN
            SS_SOL(JS,IS,KS-1)=SS_SOL(JS,IS,KS-1)
     & -VL(JS,IS,KS)*CONC(JS,IS,KS)
	    END IF  
	   END IF  
	  END IF  
C Check lower layer face
        IF(KS.LT.NSLAY) THEN
         IF(VL(JS,IS,KS+1).GT.0.0.AND.IBOUND(J,I,K+1).NE.0) THEN
          IF(IGENPT(JS,IS,KS+1).GT.0) THEN
            SS_SOL(JS,IS,KS+1)=SS_SOL(JS,IS,KS+1)+
     & VL(JS,IS,KS+1)*CONC(JS,IS,KS)
	    END IF  
	   END IF  
	  END IF  
	END IF  
C
 100  CONTINUE
C
C COMPUTE SRCAVC COMPONENT FOR MOCWT
C LOOP OVER CELLS
      DO 30 KS=1,NSLAY
      DO 30 IS=1,NSROW
      DO 30 JS=1,NSCOL
C ONLY IF SS_SRC SOURCE AT THIS CELL 
        IF(SS_SRC(JS,IS,KS).GT.0.) THEN
c include boundary source decayed (BDYD) in SRCDCY
c orig          SRCDCY=SRCDCY+(SRCD-SRCSOL(JS,IS,KS)+(BDYD-BDYSOL(JS,IS,KS)))
            SRCVOL(JS,IS,KS)=SRCVOL(JS,IS,KS)+SS_SRC(JS,IS,KS)
        END IF
   30 CONTINUE   
      RETURN
C
      END
C
C
C
C
C  PTWT1SRAV  CALCULATE AVERAGE SOURCE CONCENTRATION (SRCAVC)
C             USED FOR APPLYING SOURCE WITH WEIGHTED PARTICLE OPTION
C*************************************************************************
C
      SUBROUTINE PTWT1SRAV(SOL,SRCVOL,
     *        SRCAVC,NSCOL,NSROW,NSLAY,
     &        SOLMNW,SS_SOL)
C
      DOUBLE PRECISION DECAY
      DOUBLE PRECISION DCYFCT,DCYT,DCYT2
C
      DIMENSION SRCVOL(NSCOL,NSROW,NSLAY),SOL(NSCOL,NSROW,NSLAY),
     *          SRCAVC(NSCOL,NSROW,NSLAY)
      DIMENSION SOLMNW(NSCOL,NSROW,NSLAY),SS_SOL(NSCOL,NSROW,NSLAY)
C INITIALIZE 
      SRCAVC=0.
C LOOP OVER CELLS
      DO 30 KS=1,NSLAY
      DO 30 IS=1,NSROW
      DO 30 JS=1,NSCOL
cgzh debug
      if(js.eq.62) then
	continue
	endif
C ONLY IF SOURCE AT THIS CELL
        IF(SRCVOL(JS,IS,KS).GT.0.) THEN
C
          SOL1=SOL(JS,IS,KS)+SOLMNW(JS,IS,KS)+
     &  SS_SOL(JS,IS,KS)
          SRCAVC(JS,IS,KS)=SOL1/SRCVOL(JS,IS,KS)
        END IF
   30 CONTINUE
C
      RETURN
      END
C
C
C  GWT1VBAL1DF  READ VOLUME BALANCE FILE INFO (LIST-BASED) VBAL
C
C***************************************************************
C
      SUBROUTINE GWT1VBAL1DF(INVBAL,IOUTS,NCOL,NROW,NLAY,
     * NSCOL,NSROW,NSLAY,IGENPT)
C
C     READ IPDL FILE
C     ******************************************************************
C
      DIMENSION NPTLAYA(NSCOL,NSROW,NSLAY),NPTROWA(NSCOL,NSROW,NSLAY),
     *          NPTCOLA(NSCOL,NSROW,NSLAY)
      CHARACTER*200 LINE
C
      COMMON /SUBGRD/
     *  ISCOL1,ISCOL2,ISROW1,ISROW2,ISLAY1,ISLAY2,ISUBGD
C
C     READ COMMENTS 
      CALL URDCOM(INIPDL,IOUTS,LINE)
C     READ IPDL PARAMETERS
      LLOC=1
      CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,NPTLAY,R,IOUTS,INIPDL)
      CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,NPTROW,R,IOUTS,INIPDL)
      CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,NPTCOL,R,IOUTS,INIPDL)
      CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,NPTLIST,R,IOUTS,INIPDL)
      CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,NPMAX,R,IOUTS,INIPDL)
c      READ(INIPDL,*) NPTLAY,NPTROW,NPTCOL,NPTLIST,NPMAX
      WRITE(IOUTS,*) 'IPDL FILE PARAMETERS:'
      WRITE(IOUTS,*) 'NPTLAY  = ',NPTLAY
      WRITE(IOUTS,*) 'NPTROW  = ',NPTROW
      WRITE(IOUTS,*) 'NPTCOL  = ',NPTCOL
      WRITE(IOUTS,*) 'NPTLIST = ',NPTLIST
      WRITE(IOUTS,*) 'NPMAX   = ',NPMAX
      WRITE(IOUTS,'(/)')
C  CHECK FOR DIMENSION RESTRAINTS
      IF (NLAY.EQ.1.AND.NPTLAY.NE.1) THEN
         NPTLAY=1
	   WRITE(IOUTS,*) 'NLAY=1, RE-SETTING NPTLAY=1'
	END IF
      IF (NROW.EQ.1.AND.NPTROW.NE.1) THEN
         NPTROW=1
	   WRITE(IOUTS,*) 'NROW=1, RE-SETTING NPTROW=1'
	END IF
      IF (NCOL.EQ.1.AND.NPTCOL.NE.1) THEN
         NPTCOL=1
	   WRITE(IOUTS,*) 'NCOL=1, RE-SETTING NPTCOL=1'
	END IF
C  TRACK MAX PTS IN ANY CELL
	IF (NPMAX.EQ.0) MAXIPTS=NPTLAY*NPTROW*NPTCOL
C  FILL NPT ARRAYS
cgzh   f90 allows uniform array fill without do loop
      NPTLAYA=NPTLAY
      NPTROWA=NPTROW
      NPTCOLA=NPTCOL
C  TRACK INITIAL NUMBER OF PARTICLES IN THE GRID TO CALCULATE NLIMBO
cgzh this is npts*cells defined by background
      NPGRID=(NPTLAY*NPTROW*NPTCOL)*((NSROW*NSCOL*NSLAY)-NPTLIST)
C  READ LIST AND UPDATE ARRAYS
	DO 10 I=1,NPTLIST
        READ(INIPDL,*) IL,IR,IC,NPTLAY
        BACKSPACE INIPDL
        IF(NPTLAY.GT.0) THEN
          READ(INIPDL,*) IL,IR,IC,NPTLAY,NPTROW,NPTCOL
        ELSE
          READ(INIPDL,*) IL,IR,IC,NPTLAY
	  END IF
C CHECK FOR BAD INPUT
        IF(NPTLAY.EQ.0) THEN
	    NPTLAY=1
	    WRITE(IOUTS,*) 'NPTLAY READ AS 0, RE-SETTING NPTLAY=1'
        END IF
        IF(NPTROW.EQ.0) THEN
	    NPTROW=1
	    WRITE(IOUTS,*) 'NPTLAY READ AS 0, RE-SETTING NPTROW=1'
        END IF
        IF(NPTCOL.EQ.0) THEN
	    NPTCOL=1
	    WRITE(IOUTS,*) 'NPTLAY READ AS 0, RE-SETTING NPTCOL=1'
        END IF
C  CHECK FOR DIMENSION RESTRAINTS
        IF ((NLAY.EQ.1.AND.NPTLAY.NE.1).AND.NPTLAY.GT.0) THEN
          NPTLAY=1
	    WRITE(IOUTS,*) 'NLAY=1, RE-SETTING NPTLAY=1'
	  END IF
        IF ((NROW.EQ.1.AND.NPTROW.NE.1).AND.NPTLAY.GT.0) THEN
          NPTROW=1
	    WRITE(IOUTS,*) 'NROW=1, RE-SETTING NPTROW=1'
	  END IF
        IF ((NCOL.EQ.1.AND.NPTCOL.NE.1).AND.NPTLAY.GT.0) THEN
          NPTCOL=1
	    WRITE(IOUTS,*) 'NCOL=1, RE-SETTING NPTCOL=1'
	  END IF
cgzh square
cgzh circle
        IF(NPTLAY.LT.0) THEN
	    IF(IDIM.EQ.1) THEN
            WRITE(IOUTS,*) 'NPTLAY<0 NOT COMPATIBLE WITH ONE-D PROBLEM'
		  STOP 'ERROR IN PTWT; SEE GWT OUTPUT FILE'
          END IF
		IF(ABS(NPTLAY).LT.2) THEN
            NPTLAY=-4
	    WRITE(IOUTS,*) '***WARNING*** NPTLAY OUT OF RANGE,' 
     * ,' RE-SETTING NPTLAY=-4'		      
          END IF
        END IF
	  ICS=IC-ISCOL1+1
        IRS=IR-ISROW1+1
        ILS=IL-ISLAY1+1
cgzh check for IPDL cell outside subgrid
        IERRSG=0
        IF(ICS.LT.1.OR.ICS.GT.NSCOL) IERRSG=1
        IF(IRS.LT.1.OR.IRS.GT.NSROW) IERRSG=1
        IF(ILS.LT.1.OR.ILS.GT.NSLAY) IERRSG=1
        IF(IERRSG.EQ.1) THEN
          WRITE(IOUTS,*) ' ***ERROR*** IPDL CELL OUTSIDE SUBGRID'
          WRITE(IOUTS,*) ' CELL J,I,K', IC,IR,IL
          STOP 'ERROR IN PTWT'
        ELSE
cgzh debug this output is too lengthy for big problems
        continue
c          WRITE(IOUTS,*) 'IPDL REDEFINED AT J,I,K: ',IC,IR,IL,' AS:'
c
        END IF
	  NPTLAYA(ICS,IRS,ILS)=NPTLAY
        IF(NPTLAY.GT.0) THEN
          NPTROWA(ICS,IRS,ILS)=NPTROW
          NPTCOLA(ICS,IRS,ILS)=NPTCOL
        END IF
cgzh circle
C     CHECK FOR FLAG TO CREATE CIRCLE OF PARTICLES
cgzh square
C     CHECK FOR FLAG TO CREATE SQUARE OF PARTICLES
        IF(NPTLAY.LT.0) THEN
         WRITE(IOUTS,*) 'CIRCLE OF ',-NPTLAY,' PARTICLES'
cgzh square
c          IF(IDIM.EQ.2) THEN 
c            WRITE(IOUTS,*) 'SQUARE WITH ',-NPTLAY,
c     *      ' PARTICLES ON EACH SIDE'
c          ELSE 
c            WRITE(IOUTS,*) 'CUBE WITH ',-NPTLAY,
c     *      ' PARTICLES ON EACH SIDE'
c          END IF
C
C     IF NPTLAY IS POSITIVE, USE REGULAR DEFINITION FOR IPDL  
        ELSE
cgzh debug this output is too lengthy for big problems
        continue
c          WRITE(IOUTS,*) 'NPTLAY,NPTROW,NPTCOL= ',NPTLAY,NPTROW,NPTCOL
c
        END IF
C  TRACK MAX PTS IN ANY CELL
C  TRACK INITIAL NUMBER OF PARTICLES IN THE GRID TO CALCULATE NLIMBO
	  IF (NPMAX.EQ.0) THEN
	    IF(NPTLAY.GT.0) THEN
		  MAXIPTS=MAX(MAXIPTS,NPTLAY*NPTROW*NPTCOL)
            NPGRID=NPGRID+(NPTLAY*NPTROW*NPTCOL)
	    ELSE
cgzh square
c		  MAXIPTS=MAX(MAXIPTS,ABS((4*NPTLAY)-4))
c            NPGRID=NPGRID+(ABS((4*NPTLAY)-4))
cgzh circle
		  MAXIPTS=MAX(MAXIPTS,ABS(NPTLAY))
            NPGRID=NPGRID+(ABS(NPTLAY))
          END IF
        END IF
  10  CONTINUE
C  CALCULATE DEFAULT NPMAX VALUE
      WRITE(IOUTS,'(/)')
	IF (NPMAX.EQ.0) THEN
C  Changed definition for weighted, base it on NPGRID 
cgzh        NPMAX=2*MAXIPTS*NSCOL*NSROW*NSLAY
        NPMAX=2*NPGRID
C
        WRITE(IOUTS,*) 'NPMAX=0, USING DEFAULT CALCULATION'
        WRITE(IOUTS,*) 'MAXIPTS= ',MAXIPTS,'; NPMAX= ',NPMAX
        WRITE(IOUTS,'(/)')
      END IF
C  CALCULATE NLIMBO
      NLIMBO=500
      NTEMP=NPGRID/25
      IF(NTEMP.GT.NLIMBO) NLIMBO=NTEMP
C
      RETURN
      END
     